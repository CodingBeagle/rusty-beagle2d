/* automatically generated by rust-bindgen */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const WINAPI_FAMILY_PC_APP: u32 = 2;
pub const WINAPI_FAMILY_PHONE_APP: u32 = 3;
pub const WINAPI_FAMILY_SYSTEM: u32 = 4;
pub const WINAPI_FAMILY_SERVER: u32 = 5;
pub const WINAPI_FAMILY_DESKTOP_APP: u32 = 100;
pub const WINAPI_FAMILY_APP: u32 = 2;
pub const WINAPI_FAMILY: u32 = 100;
pub const GL_VERSION_1_1: u32 = 1;
pub const GL_ACCUM: u32 = 256;
pub const GL_LOAD: u32 = 257;
pub const GL_RETURN: u32 = 258;
pub const GL_MULT: u32 = 259;
pub const GL_ADD: u32 = 260;
pub const GL_NEVER: u32 = 512;
pub const GL_LESS: u32 = 513;
pub const GL_EQUAL: u32 = 514;
pub const GL_LEQUAL: u32 = 515;
pub const GL_GREATER: u32 = 516;
pub const GL_NOTEQUAL: u32 = 517;
pub const GL_GEQUAL: u32 = 518;
pub const GL_ALWAYS: u32 = 519;
pub const GL_CURRENT_BIT: u32 = 1;
pub const GL_POINT_BIT: u32 = 2;
pub const GL_LINE_BIT: u32 = 4;
pub const GL_POLYGON_BIT: u32 = 8;
pub const GL_POLYGON_STIPPLE_BIT: u32 = 16;
pub const GL_PIXEL_MODE_BIT: u32 = 32;
pub const GL_LIGHTING_BIT: u32 = 64;
pub const GL_FOG_BIT: u32 = 128;
pub const GL_DEPTH_BUFFER_BIT: u32 = 256;
pub const GL_ACCUM_BUFFER_BIT: u32 = 512;
pub const GL_STENCIL_BUFFER_BIT: u32 = 1024;
pub const GL_VIEWPORT_BIT: u32 = 2048;
pub const GL_TRANSFORM_BIT: u32 = 4096;
pub const GL_ENABLE_BIT: u32 = 8192;
pub const GL_COLOR_BUFFER_BIT: u32 = 16384;
pub const GL_HINT_BIT: u32 = 32768;
pub const GL_EVAL_BIT: u32 = 65536;
pub const GL_LIST_BIT: u32 = 131072;
pub const GL_TEXTURE_BIT: u32 = 262144;
pub const GL_SCISSOR_BIT: u32 = 524288;
pub const GL_ALL_ATTRIB_BITS: u32 = 1048575;
pub const GL_POINTS: u32 = 0;
pub const GL_LINES: u32 = 1;
pub const GL_LINE_LOOP: u32 = 2;
pub const GL_LINE_STRIP: u32 = 3;
pub const GL_TRIANGLES: u32 = 4;
pub const GL_TRIANGLE_STRIP: u32 = 5;
pub const GL_TRIANGLE_FAN: u32 = 6;
pub const GL_QUADS: u32 = 7;
pub const GL_QUAD_STRIP: u32 = 8;
pub const GL_POLYGON: u32 = 9;
pub const GL_ZERO: u32 = 0;
pub const GL_ONE: u32 = 1;
pub const GL_SRC_COLOR: u32 = 768;
pub const GL_ONE_MINUS_SRC_COLOR: u32 = 769;
pub const GL_SRC_ALPHA: u32 = 770;
pub const GL_ONE_MINUS_SRC_ALPHA: u32 = 771;
pub const GL_DST_ALPHA: u32 = 772;
pub const GL_ONE_MINUS_DST_ALPHA: u32 = 773;
pub const GL_DST_COLOR: u32 = 774;
pub const GL_ONE_MINUS_DST_COLOR: u32 = 775;
pub const GL_SRC_ALPHA_SATURATE: u32 = 776;
pub const GL_TRUE: u32 = 1;
pub const GL_FALSE: u32 = 0;
pub const GL_CLIP_PLANE0: u32 = 12288;
pub const GL_CLIP_PLANE1: u32 = 12289;
pub const GL_CLIP_PLANE2: u32 = 12290;
pub const GL_CLIP_PLANE3: u32 = 12291;
pub const GL_CLIP_PLANE4: u32 = 12292;
pub const GL_CLIP_PLANE5: u32 = 12293;
pub const GL_BYTE: u32 = 5120;
pub const GL_UNSIGNED_BYTE: u32 = 5121;
pub const GL_SHORT: u32 = 5122;
pub const GL_UNSIGNED_SHORT: u32 = 5123;
pub const GL_INT: u32 = 5124;
pub const GL_UNSIGNED_INT: u32 = 5125;
pub const GL_FLOAT: u32 = 5126;
pub const GL_2_BYTES: u32 = 5127;
pub const GL_3_BYTES: u32 = 5128;
pub const GL_4_BYTES: u32 = 5129;
pub const GL_DOUBLE: u32 = 5130;
pub const GL_NONE: u32 = 0;
pub const GL_FRONT_LEFT: u32 = 1024;
pub const GL_FRONT_RIGHT: u32 = 1025;
pub const GL_BACK_LEFT: u32 = 1026;
pub const GL_BACK_RIGHT: u32 = 1027;
pub const GL_FRONT: u32 = 1028;
pub const GL_BACK: u32 = 1029;
pub const GL_LEFT: u32 = 1030;
pub const GL_RIGHT: u32 = 1031;
pub const GL_FRONT_AND_BACK: u32 = 1032;
pub const GL_AUX0: u32 = 1033;
pub const GL_AUX1: u32 = 1034;
pub const GL_AUX2: u32 = 1035;
pub const GL_AUX3: u32 = 1036;
pub const GL_NO_ERROR: u32 = 0;
pub const GL_INVALID_ENUM: u32 = 1280;
pub const GL_INVALID_VALUE: u32 = 1281;
pub const GL_INVALID_OPERATION: u32 = 1282;
pub const GL_STACK_OVERFLOW: u32 = 1283;
pub const GL_STACK_UNDERFLOW: u32 = 1284;
pub const GL_OUT_OF_MEMORY: u32 = 1285;
pub const GL_2D: u32 = 1536;
pub const GL_3D: u32 = 1537;
pub const GL_3D_COLOR: u32 = 1538;
pub const GL_3D_COLOR_TEXTURE: u32 = 1539;
pub const GL_4D_COLOR_TEXTURE: u32 = 1540;
pub const GL_PASS_THROUGH_TOKEN: u32 = 1792;
pub const GL_POINT_TOKEN: u32 = 1793;
pub const GL_LINE_TOKEN: u32 = 1794;
pub const GL_POLYGON_TOKEN: u32 = 1795;
pub const GL_BITMAP_TOKEN: u32 = 1796;
pub const GL_DRAW_PIXEL_TOKEN: u32 = 1797;
pub const GL_COPY_PIXEL_TOKEN: u32 = 1798;
pub const GL_LINE_RESET_TOKEN: u32 = 1799;
pub const GL_EXP: u32 = 2048;
pub const GL_EXP2: u32 = 2049;
pub const GL_CW: u32 = 2304;
pub const GL_CCW: u32 = 2305;
pub const GL_COEFF: u32 = 2560;
pub const GL_ORDER: u32 = 2561;
pub const GL_DOMAIN: u32 = 2562;
pub const GL_CURRENT_COLOR: u32 = 2816;
pub const GL_CURRENT_INDEX: u32 = 2817;
pub const GL_CURRENT_NORMAL: u32 = 2818;
pub const GL_CURRENT_TEXTURE_COORDS: u32 = 2819;
pub const GL_CURRENT_RASTER_COLOR: u32 = 2820;
pub const GL_CURRENT_RASTER_INDEX: u32 = 2821;
pub const GL_CURRENT_RASTER_TEXTURE_COORDS: u32 = 2822;
pub const GL_CURRENT_RASTER_POSITION: u32 = 2823;
pub const GL_CURRENT_RASTER_POSITION_VALID: u32 = 2824;
pub const GL_CURRENT_RASTER_DISTANCE: u32 = 2825;
pub const GL_POINT_SMOOTH: u32 = 2832;
pub const GL_POINT_SIZE: u32 = 2833;
pub const GL_POINT_SIZE_RANGE: u32 = 2834;
pub const GL_POINT_SIZE_GRANULARITY: u32 = 2835;
pub const GL_LINE_SMOOTH: u32 = 2848;
pub const GL_LINE_WIDTH: u32 = 2849;
pub const GL_LINE_WIDTH_RANGE: u32 = 2850;
pub const GL_LINE_WIDTH_GRANULARITY: u32 = 2851;
pub const GL_LINE_STIPPLE: u32 = 2852;
pub const GL_LINE_STIPPLE_PATTERN: u32 = 2853;
pub const GL_LINE_STIPPLE_REPEAT: u32 = 2854;
pub const GL_LIST_MODE: u32 = 2864;
pub const GL_MAX_LIST_NESTING: u32 = 2865;
pub const GL_LIST_BASE: u32 = 2866;
pub const GL_LIST_INDEX: u32 = 2867;
pub const GL_POLYGON_MODE: u32 = 2880;
pub const GL_POLYGON_SMOOTH: u32 = 2881;
pub const GL_POLYGON_STIPPLE: u32 = 2882;
pub const GL_EDGE_FLAG: u32 = 2883;
pub const GL_CULL_FACE: u32 = 2884;
pub const GL_CULL_FACE_MODE: u32 = 2885;
pub const GL_FRONT_FACE: u32 = 2886;
pub const GL_LIGHTING: u32 = 2896;
pub const GL_LIGHT_MODEL_LOCAL_VIEWER: u32 = 2897;
pub const GL_LIGHT_MODEL_TWO_SIDE: u32 = 2898;
pub const GL_LIGHT_MODEL_AMBIENT: u32 = 2899;
pub const GL_SHADE_MODEL: u32 = 2900;
pub const GL_COLOR_MATERIAL_FACE: u32 = 2901;
pub const GL_COLOR_MATERIAL_PARAMETER: u32 = 2902;
pub const GL_COLOR_MATERIAL: u32 = 2903;
pub const GL_FOG: u32 = 2912;
pub const GL_FOG_INDEX: u32 = 2913;
pub const GL_FOG_DENSITY: u32 = 2914;
pub const GL_FOG_START: u32 = 2915;
pub const GL_FOG_END: u32 = 2916;
pub const GL_FOG_MODE: u32 = 2917;
pub const GL_FOG_COLOR: u32 = 2918;
pub const GL_DEPTH_RANGE: u32 = 2928;
pub const GL_DEPTH_TEST: u32 = 2929;
pub const GL_DEPTH_WRITEMASK: u32 = 2930;
pub const GL_DEPTH_CLEAR_VALUE: u32 = 2931;
pub const GL_DEPTH_FUNC: u32 = 2932;
pub const GL_ACCUM_CLEAR_VALUE: u32 = 2944;
pub const GL_STENCIL_TEST: u32 = 2960;
pub const GL_STENCIL_CLEAR_VALUE: u32 = 2961;
pub const GL_STENCIL_FUNC: u32 = 2962;
pub const GL_STENCIL_VALUE_MASK: u32 = 2963;
pub const GL_STENCIL_FAIL: u32 = 2964;
pub const GL_STENCIL_PASS_DEPTH_FAIL: u32 = 2965;
pub const GL_STENCIL_PASS_DEPTH_PASS: u32 = 2966;
pub const GL_STENCIL_REF: u32 = 2967;
pub const GL_STENCIL_WRITEMASK: u32 = 2968;
pub const GL_MATRIX_MODE: u32 = 2976;
pub const GL_NORMALIZE: u32 = 2977;
pub const GL_VIEWPORT: u32 = 2978;
pub const GL_MODELVIEW_STACK_DEPTH: u32 = 2979;
pub const GL_PROJECTION_STACK_DEPTH: u32 = 2980;
pub const GL_TEXTURE_STACK_DEPTH: u32 = 2981;
pub const GL_MODELVIEW_MATRIX: u32 = 2982;
pub const GL_PROJECTION_MATRIX: u32 = 2983;
pub const GL_TEXTURE_MATRIX: u32 = 2984;
pub const GL_ATTRIB_STACK_DEPTH: u32 = 2992;
pub const GL_CLIENT_ATTRIB_STACK_DEPTH: u32 = 2993;
pub const GL_ALPHA_TEST: u32 = 3008;
pub const GL_ALPHA_TEST_FUNC: u32 = 3009;
pub const GL_ALPHA_TEST_REF: u32 = 3010;
pub const GL_DITHER: u32 = 3024;
pub const GL_BLEND_DST: u32 = 3040;
pub const GL_BLEND_SRC: u32 = 3041;
pub const GL_BLEND: u32 = 3042;
pub const GL_LOGIC_OP_MODE: u32 = 3056;
pub const GL_INDEX_LOGIC_OP: u32 = 3057;
pub const GL_COLOR_LOGIC_OP: u32 = 3058;
pub const GL_AUX_BUFFERS: u32 = 3072;
pub const GL_DRAW_BUFFER: u32 = 3073;
pub const GL_READ_BUFFER: u32 = 3074;
pub const GL_SCISSOR_BOX: u32 = 3088;
pub const GL_SCISSOR_TEST: u32 = 3089;
pub const GL_INDEX_CLEAR_VALUE: u32 = 3104;
pub const GL_INDEX_WRITEMASK: u32 = 3105;
pub const GL_COLOR_CLEAR_VALUE: u32 = 3106;
pub const GL_COLOR_WRITEMASK: u32 = 3107;
pub const GL_INDEX_MODE: u32 = 3120;
pub const GL_RGBA_MODE: u32 = 3121;
pub const GL_DOUBLEBUFFER: u32 = 3122;
pub const GL_STEREO: u32 = 3123;
pub const GL_RENDER_MODE: u32 = 3136;
pub const GL_PERSPECTIVE_CORRECTION_HINT: u32 = 3152;
pub const GL_POINT_SMOOTH_HINT: u32 = 3153;
pub const GL_LINE_SMOOTH_HINT: u32 = 3154;
pub const GL_POLYGON_SMOOTH_HINT: u32 = 3155;
pub const GL_FOG_HINT: u32 = 3156;
pub const GL_TEXTURE_GEN_S: u32 = 3168;
pub const GL_TEXTURE_GEN_T: u32 = 3169;
pub const GL_TEXTURE_GEN_R: u32 = 3170;
pub const GL_TEXTURE_GEN_Q: u32 = 3171;
pub const GL_PIXEL_MAP_I_TO_I: u32 = 3184;
pub const GL_PIXEL_MAP_S_TO_S: u32 = 3185;
pub const GL_PIXEL_MAP_I_TO_R: u32 = 3186;
pub const GL_PIXEL_MAP_I_TO_G: u32 = 3187;
pub const GL_PIXEL_MAP_I_TO_B: u32 = 3188;
pub const GL_PIXEL_MAP_I_TO_A: u32 = 3189;
pub const GL_PIXEL_MAP_R_TO_R: u32 = 3190;
pub const GL_PIXEL_MAP_G_TO_G: u32 = 3191;
pub const GL_PIXEL_MAP_B_TO_B: u32 = 3192;
pub const GL_PIXEL_MAP_A_TO_A: u32 = 3193;
pub const GL_PIXEL_MAP_I_TO_I_SIZE: u32 = 3248;
pub const GL_PIXEL_MAP_S_TO_S_SIZE: u32 = 3249;
pub const GL_PIXEL_MAP_I_TO_R_SIZE: u32 = 3250;
pub const GL_PIXEL_MAP_I_TO_G_SIZE: u32 = 3251;
pub const GL_PIXEL_MAP_I_TO_B_SIZE: u32 = 3252;
pub const GL_PIXEL_MAP_I_TO_A_SIZE: u32 = 3253;
pub const GL_PIXEL_MAP_R_TO_R_SIZE: u32 = 3254;
pub const GL_PIXEL_MAP_G_TO_G_SIZE: u32 = 3255;
pub const GL_PIXEL_MAP_B_TO_B_SIZE: u32 = 3256;
pub const GL_PIXEL_MAP_A_TO_A_SIZE: u32 = 3257;
pub const GL_UNPACK_SWAP_BYTES: u32 = 3312;
pub const GL_UNPACK_LSB_FIRST: u32 = 3313;
pub const GL_UNPACK_ROW_LENGTH: u32 = 3314;
pub const GL_UNPACK_SKIP_ROWS: u32 = 3315;
pub const GL_UNPACK_SKIP_PIXELS: u32 = 3316;
pub const GL_UNPACK_ALIGNMENT: u32 = 3317;
pub const GL_PACK_SWAP_BYTES: u32 = 3328;
pub const GL_PACK_LSB_FIRST: u32 = 3329;
pub const GL_PACK_ROW_LENGTH: u32 = 3330;
pub const GL_PACK_SKIP_ROWS: u32 = 3331;
pub const GL_PACK_SKIP_PIXELS: u32 = 3332;
pub const GL_PACK_ALIGNMENT: u32 = 3333;
pub const GL_MAP_COLOR: u32 = 3344;
pub const GL_MAP_STENCIL: u32 = 3345;
pub const GL_INDEX_SHIFT: u32 = 3346;
pub const GL_INDEX_OFFSET: u32 = 3347;
pub const GL_RED_SCALE: u32 = 3348;
pub const GL_RED_BIAS: u32 = 3349;
pub const GL_ZOOM_X: u32 = 3350;
pub const GL_ZOOM_Y: u32 = 3351;
pub const GL_GREEN_SCALE: u32 = 3352;
pub const GL_GREEN_BIAS: u32 = 3353;
pub const GL_BLUE_SCALE: u32 = 3354;
pub const GL_BLUE_BIAS: u32 = 3355;
pub const GL_ALPHA_SCALE: u32 = 3356;
pub const GL_ALPHA_BIAS: u32 = 3357;
pub const GL_DEPTH_SCALE: u32 = 3358;
pub const GL_DEPTH_BIAS: u32 = 3359;
pub const GL_MAX_EVAL_ORDER: u32 = 3376;
pub const GL_MAX_LIGHTS: u32 = 3377;
pub const GL_MAX_CLIP_PLANES: u32 = 3378;
pub const GL_MAX_TEXTURE_SIZE: u32 = 3379;
pub const GL_MAX_PIXEL_MAP_TABLE: u32 = 3380;
pub const GL_MAX_ATTRIB_STACK_DEPTH: u32 = 3381;
pub const GL_MAX_MODELVIEW_STACK_DEPTH: u32 = 3382;
pub const GL_MAX_NAME_STACK_DEPTH: u32 = 3383;
pub const GL_MAX_PROJECTION_STACK_DEPTH: u32 = 3384;
pub const GL_MAX_TEXTURE_STACK_DEPTH: u32 = 3385;
pub const GL_MAX_VIEWPORT_DIMS: u32 = 3386;
pub const GL_MAX_CLIENT_ATTRIB_STACK_DEPTH: u32 = 3387;
pub const GL_SUBPIXEL_BITS: u32 = 3408;
pub const GL_INDEX_BITS: u32 = 3409;
pub const GL_RED_BITS: u32 = 3410;
pub const GL_GREEN_BITS: u32 = 3411;
pub const GL_BLUE_BITS: u32 = 3412;
pub const GL_ALPHA_BITS: u32 = 3413;
pub const GL_DEPTH_BITS: u32 = 3414;
pub const GL_STENCIL_BITS: u32 = 3415;
pub const GL_ACCUM_RED_BITS: u32 = 3416;
pub const GL_ACCUM_GREEN_BITS: u32 = 3417;
pub const GL_ACCUM_BLUE_BITS: u32 = 3418;
pub const GL_ACCUM_ALPHA_BITS: u32 = 3419;
pub const GL_NAME_STACK_DEPTH: u32 = 3440;
pub const GL_AUTO_NORMAL: u32 = 3456;
pub const GL_MAP1_COLOR_4: u32 = 3472;
pub const GL_MAP1_INDEX: u32 = 3473;
pub const GL_MAP1_NORMAL: u32 = 3474;
pub const GL_MAP1_TEXTURE_COORD_1: u32 = 3475;
pub const GL_MAP1_TEXTURE_COORD_2: u32 = 3476;
pub const GL_MAP1_TEXTURE_COORD_3: u32 = 3477;
pub const GL_MAP1_TEXTURE_COORD_4: u32 = 3478;
pub const GL_MAP1_VERTEX_3: u32 = 3479;
pub const GL_MAP1_VERTEX_4: u32 = 3480;
pub const GL_MAP2_COLOR_4: u32 = 3504;
pub const GL_MAP2_INDEX: u32 = 3505;
pub const GL_MAP2_NORMAL: u32 = 3506;
pub const GL_MAP2_TEXTURE_COORD_1: u32 = 3507;
pub const GL_MAP2_TEXTURE_COORD_2: u32 = 3508;
pub const GL_MAP2_TEXTURE_COORD_3: u32 = 3509;
pub const GL_MAP2_TEXTURE_COORD_4: u32 = 3510;
pub const GL_MAP2_VERTEX_3: u32 = 3511;
pub const GL_MAP2_VERTEX_4: u32 = 3512;
pub const GL_MAP1_GRID_DOMAIN: u32 = 3536;
pub const GL_MAP1_GRID_SEGMENTS: u32 = 3537;
pub const GL_MAP2_GRID_DOMAIN: u32 = 3538;
pub const GL_MAP2_GRID_SEGMENTS: u32 = 3539;
pub const GL_TEXTURE_1D: u32 = 3552;
pub const GL_TEXTURE_2D: u32 = 3553;
pub const GL_FEEDBACK_BUFFER_POINTER: u32 = 3568;
pub const GL_FEEDBACK_BUFFER_SIZE: u32 = 3569;
pub const GL_FEEDBACK_BUFFER_TYPE: u32 = 3570;
pub const GL_SELECTION_BUFFER_POINTER: u32 = 3571;
pub const GL_SELECTION_BUFFER_SIZE: u32 = 3572;
pub const GL_TEXTURE_WIDTH: u32 = 4096;
pub const GL_TEXTURE_HEIGHT: u32 = 4097;
pub const GL_TEXTURE_INTERNAL_FORMAT: u32 = 4099;
pub const GL_TEXTURE_BORDER_COLOR: u32 = 4100;
pub const GL_TEXTURE_BORDER: u32 = 4101;
pub const GL_DONT_CARE: u32 = 4352;
pub const GL_FASTEST: u32 = 4353;
pub const GL_NICEST: u32 = 4354;
pub const GL_LIGHT0: u32 = 16384;
pub const GL_LIGHT1: u32 = 16385;
pub const GL_LIGHT2: u32 = 16386;
pub const GL_LIGHT3: u32 = 16387;
pub const GL_LIGHT4: u32 = 16388;
pub const GL_LIGHT5: u32 = 16389;
pub const GL_LIGHT6: u32 = 16390;
pub const GL_LIGHT7: u32 = 16391;
pub const GL_AMBIENT: u32 = 4608;
pub const GL_DIFFUSE: u32 = 4609;
pub const GL_SPECULAR: u32 = 4610;
pub const GL_POSITION: u32 = 4611;
pub const GL_SPOT_DIRECTION: u32 = 4612;
pub const GL_SPOT_EXPONENT: u32 = 4613;
pub const GL_SPOT_CUTOFF: u32 = 4614;
pub const GL_CONSTANT_ATTENUATION: u32 = 4615;
pub const GL_LINEAR_ATTENUATION: u32 = 4616;
pub const GL_QUADRATIC_ATTENUATION: u32 = 4617;
pub const GL_COMPILE: u32 = 4864;
pub const GL_COMPILE_AND_EXECUTE: u32 = 4865;
pub const GL_CLEAR: u32 = 5376;
pub const GL_AND: u32 = 5377;
pub const GL_AND_REVERSE: u32 = 5378;
pub const GL_COPY: u32 = 5379;
pub const GL_AND_INVERTED: u32 = 5380;
pub const GL_NOOP: u32 = 5381;
pub const GL_XOR: u32 = 5382;
pub const GL_OR: u32 = 5383;
pub const GL_NOR: u32 = 5384;
pub const GL_EQUIV: u32 = 5385;
pub const GL_INVERT: u32 = 5386;
pub const GL_OR_REVERSE: u32 = 5387;
pub const GL_COPY_INVERTED: u32 = 5388;
pub const GL_OR_INVERTED: u32 = 5389;
pub const GL_NAND: u32 = 5390;
pub const GL_SET: u32 = 5391;
pub const GL_EMISSION: u32 = 5632;
pub const GL_SHININESS: u32 = 5633;
pub const GL_AMBIENT_AND_DIFFUSE: u32 = 5634;
pub const GL_COLOR_INDEXES: u32 = 5635;
pub const GL_MODELVIEW: u32 = 5888;
pub const GL_PROJECTION: u32 = 5889;
pub const GL_TEXTURE: u32 = 5890;
pub const GL_COLOR: u32 = 6144;
pub const GL_DEPTH: u32 = 6145;
pub const GL_STENCIL: u32 = 6146;
pub const GL_COLOR_INDEX: u32 = 6400;
pub const GL_STENCIL_INDEX: u32 = 6401;
pub const GL_DEPTH_COMPONENT: u32 = 6402;
pub const GL_RED: u32 = 6403;
pub const GL_GREEN: u32 = 6404;
pub const GL_BLUE: u32 = 6405;
pub const GL_ALPHA: u32 = 6406;
pub const GL_RGB: u32 = 6407;
pub const GL_RGBA: u32 = 6408;
pub const GL_LUMINANCE: u32 = 6409;
pub const GL_LUMINANCE_ALPHA: u32 = 6410;
pub const GL_BITMAP: u32 = 6656;
pub const GL_POINT: u32 = 6912;
pub const GL_LINE: u32 = 6913;
pub const GL_FILL: u32 = 6914;
pub const GL_RENDER: u32 = 7168;
pub const GL_FEEDBACK: u32 = 7169;
pub const GL_SELECT: u32 = 7170;
pub const GL_FLAT: u32 = 7424;
pub const GL_SMOOTH: u32 = 7425;
pub const GL_KEEP: u32 = 7680;
pub const GL_REPLACE: u32 = 7681;
pub const GL_INCR: u32 = 7682;
pub const GL_DECR: u32 = 7683;
pub const GL_VENDOR: u32 = 7936;
pub const GL_RENDERER: u32 = 7937;
pub const GL_VERSION: u32 = 7938;
pub const GL_EXTENSIONS: u32 = 7939;
pub const GL_S: u32 = 8192;
pub const GL_T: u32 = 8193;
pub const GL_R: u32 = 8194;
pub const GL_Q: u32 = 8195;
pub const GL_MODULATE: u32 = 8448;
pub const GL_DECAL: u32 = 8449;
pub const GL_TEXTURE_ENV_MODE: u32 = 8704;
pub const GL_TEXTURE_ENV_COLOR: u32 = 8705;
pub const GL_TEXTURE_ENV: u32 = 8960;
pub const GL_EYE_LINEAR: u32 = 9216;
pub const GL_OBJECT_LINEAR: u32 = 9217;
pub const GL_SPHERE_MAP: u32 = 9218;
pub const GL_TEXTURE_GEN_MODE: u32 = 9472;
pub const GL_OBJECT_PLANE: u32 = 9473;
pub const GL_EYE_PLANE: u32 = 9474;
pub const GL_NEAREST: u32 = 9728;
pub const GL_LINEAR: u32 = 9729;
pub const GL_NEAREST_MIPMAP_NEAREST: u32 = 9984;
pub const GL_LINEAR_MIPMAP_NEAREST: u32 = 9985;
pub const GL_NEAREST_MIPMAP_LINEAR: u32 = 9986;
pub const GL_LINEAR_MIPMAP_LINEAR: u32 = 9987;
pub const GL_TEXTURE_MAG_FILTER: u32 = 10240;
pub const GL_TEXTURE_MIN_FILTER: u32 = 10241;
pub const GL_TEXTURE_WRAP_S: u32 = 10242;
pub const GL_TEXTURE_WRAP_T: u32 = 10243;
pub const GL_CLAMP: u32 = 10496;
pub const GL_REPEAT: u32 = 10497;
pub const GL_CLIENT_PIXEL_STORE_BIT: u32 = 1;
pub const GL_CLIENT_VERTEX_ARRAY_BIT: u32 = 2;
pub const GL_CLIENT_ALL_ATTRIB_BITS: u32 = 4294967295;
pub const GL_POLYGON_OFFSET_FACTOR: u32 = 32824;
pub const GL_POLYGON_OFFSET_UNITS: u32 = 10752;
pub const GL_POLYGON_OFFSET_POINT: u32 = 10753;
pub const GL_POLYGON_OFFSET_LINE: u32 = 10754;
pub const GL_POLYGON_OFFSET_FILL: u32 = 32823;
pub const GL_ALPHA4: u32 = 32827;
pub const GL_ALPHA8: u32 = 32828;
pub const GL_ALPHA12: u32 = 32829;
pub const GL_ALPHA16: u32 = 32830;
pub const GL_LUMINANCE4: u32 = 32831;
pub const GL_LUMINANCE8: u32 = 32832;
pub const GL_LUMINANCE12: u32 = 32833;
pub const GL_LUMINANCE16: u32 = 32834;
pub const GL_LUMINANCE4_ALPHA4: u32 = 32835;
pub const GL_LUMINANCE6_ALPHA2: u32 = 32836;
pub const GL_LUMINANCE8_ALPHA8: u32 = 32837;
pub const GL_LUMINANCE12_ALPHA4: u32 = 32838;
pub const GL_LUMINANCE12_ALPHA12: u32 = 32839;
pub const GL_LUMINANCE16_ALPHA16: u32 = 32840;
pub const GL_INTENSITY: u32 = 32841;
pub const GL_INTENSITY4: u32 = 32842;
pub const GL_INTENSITY8: u32 = 32843;
pub const GL_INTENSITY12: u32 = 32844;
pub const GL_INTENSITY16: u32 = 32845;
pub const GL_R3_G3_B2: u32 = 10768;
pub const GL_RGB4: u32 = 32847;
pub const GL_RGB5: u32 = 32848;
pub const GL_RGB8: u32 = 32849;
pub const GL_RGB10: u32 = 32850;
pub const GL_RGB12: u32 = 32851;
pub const GL_RGB16: u32 = 32852;
pub const GL_RGBA2: u32 = 32853;
pub const GL_RGBA4: u32 = 32854;
pub const GL_RGB5_A1: u32 = 32855;
pub const GL_RGBA8: u32 = 32856;
pub const GL_RGB10_A2: u32 = 32857;
pub const GL_RGBA12: u32 = 32858;
pub const GL_RGBA16: u32 = 32859;
pub const GL_TEXTURE_RED_SIZE: u32 = 32860;
pub const GL_TEXTURE_GREEN_SIZE: u32 = 32861;
pub const GL_TEXTURE_BLUE_SIZE: u32 = 32862;
pub const GL_TEXTURE_ALPHA_SIZE: u32 = 32863;
pub const GL_TEXTURE_LUMINANCE_SIZE: u32 = 32864;
pub const GL_TEXTURE_INTENSITY_SIZE: u32 = 32865;
pub const GL_PROXY_TEXTURE_1D: u32 = 32867;
pub const GL_PROXY_TEXTURE_2D: u32 = 32868;
pub const GL_TEXTURE_PRIORITY: u32 = 32870;
pub const GL_TEXTURE_RESIDENT: u32 = 32871;
pub const GL_TEXTURE_BINDING_1D: u32 = 32872;
pub const GL_TEXTURE_BINDING_2D: u32 = 32873;
pub const GL_VERTEX_ARRAY: u32 = 32884;
pub const GL_NORMAL_ARRAY: u32 = 32885;
pub const GL_COLOR_ARRAY: u32 = 32886;
pub const GL_INDEX_ARRAY: u32 = 32887;
pub const GL_TEXTURE_COORD_ARRAY: u32 = 32888;
pub const GL_EDGE_FLAG_ARRAY: u32 = 32889;
pub const GL_VERTEX_ARRAY_SIZE: u32 = 32890;
pub const GL_VERTEX_ARRAY_TYPE: u32 = 32891;
pub const GL_VERTEX_ARRAY_STRIDE: u32 = 32892;
pub const GL_NORMAL_ARRAY_TYPE: u32 = 32894;
pub const GL_NORMAL_ARRAY_STRIDE: u32 = 32895;
pub const GL_COLOR_ARRAY_SIZE: u32 = 32897;
pub const GL_COLOR_ARRAY_TYPE: u32 = 32898;
pub const GL_COLOR_ARRAY_STRIDE: u32 = 32899;
pub const GL_INDEX_ARRAY_TYPE: u32 = 32901;
pub const GL_INDEX_ARRAY_STRIDE: u32 = 32902;
pub const GL_TEXTURE_COORD_ARRAY_SIZE: u32 = 32904;
pub const GL_TEXTURE_COORD_ARRAY_TYPE: u32 = 32905;
pub const GL_TEXTURE_COORD_ARRAY_STRIDE: u32 = 32906;
pub const GL_EDGE_FLAG_ARRAY_STRIDE: u32 = 32908;
pub const GL_VERTEX_ARRAY_POINTER: u32 = 32910;
pub const GL_NORMAL_ARRAY_POINTER: u32 = 32911;
pub const GL_COLOR_ARRAY_POINTER: u32 = 32912;
pub const GL_INDEX_ARRAY_POINTER: u32 = 32913;
pub const GL_TEXTURE_COORD_ARRAY_POINTER: u32 = 32914;
pub const GL_EDGE_FLAG_ARRAY_POINTER: u32 = 32915;
pub const GL_V2F: u32 = 10784;
pub const GL_V3F: u32 = 10785;
pub const GL_C4UB_V2F: u32 = 10786;
pub const GL_C4UB_V3F: u32 = 10787;
pub const GL_C3F_V3F: u32 = 10788;
pub const GL_N3F_V3F: u32 = 10789;
pub const GL_C4F_N3F_V3F: u32 = 10790;
pub const GL_T2F_V3F: u32 = 10791;
pub const GL_T4F_V4F: u32 = 10792;
pub const GL_T2F_C4UB_V3F: u32 = 10793;
pub const GL_T2F_C3F_V3F: u32 = 10794;
pub const GL_T2F_N3F_V3F: u32 = 10795;
pub const GL_T2F_C4F_N3F_V3F: u32 = 10796;
pub const GL_T4F_C4F_N3F_V4F: u32 = 10797;
pub const GL_EXT_vertex_array: u32 = 1;
pub const GL_EXT_bgra: u32 = 1;
pub const GL_EXT_paletted_texture: u32 = 1;
pub const GL_WIN_swap_hint: u32 = 1;
pub const GL_WIN_draw_range_elements: u32 = 1;
pub const GL_VERTEX_ARRAY_EXT: u32 = 32884;
pub const GL_NORMAL_ARRAY_EXT: u32 = 32885;
pub const GL_COLOR_ARRAY_EXT: u32 = 32886;
pub const GL_INDEX_ARRAY_EXT: u32 = 32887;
pub const GL_TEXTURE_COORD_ARRAY_EXT: u32 = 32888;
pub const GL_EDGE_FLAG_ARRAY_EXT: u32 = 32889;
pub const GL_VERTEX_ARRAY_SIZE_EXT: u32 = 32890;
pub const GL_VERTEX_ARRAY_TYPE_EXT: u32 = 32891;
pub const GL_VERTEX_ARRAY_STRIDE_EXT: u32 = 32892;
pub const GL_VERTEX_ARRAY_COUNT_EXT: u32 = 32893;
pub const GL_NORMAL_ARRAY_TYPE_EXT: u32 = 32894;
pub const GL_NORMAL_ARRAY_STRIDE_EXT: u32 = 32895;
pub const GL_NORMAL_ARRAY_COUNT_EXT: u32 = 32896;
pub const GL_COLOR_ARRAY_SIZE_EXT: u32 = 32897;
pub const GL_COLOR_ARRAY_TYPE_EXT: u32 = 32898;
pub const GL_COLOR_ARRAY_STRIDE_EXT: u32 = 32899;
pub const GL_COLOR_ARRAY_COUNT_EXT: u32 = 32900;
pub const GL_INDEX_ARRAY_TYPE_EXT: u32 = 32901;
pub const GL_INDEX_ARRAY_STRIDE_EXT: u32 = 32902;
pub const GL_INDEX_ARRAY_COUNT_EXT: u32 = 32903;
pub const GL_TEXTURE_COORD_ARRAY_SIZE_EXT: u32 = 32904;
pub const GL_TEXTURE_COORD_ARRAY_TYPE_EXT: u32 = 32905;
pub const GL_TEXTURE_COORD_ARRAY_STRIDE_EXT: u32 = 32906;
pub const GL_TEXTURE_COORD_ARRAY_COUNT_EXT: u32 = 32907;
pub const GL_EDGE_FLAG_ARRAY_STRIDE_EXT: u32 = 32908;
pub const GL_EDGE_FLAG_ARRAY_COUNT_EXT: u32 = 32909;
pub const GL_VERTEX_ARRAY_POINTER_EXT: u32 = 32910;
pub const GL_NORMAL_ARRAY_POINTER_EXT: u32 = 32911;
pub const GL_COLOR_ARRAY_POINTER_EXT: u32 = 32912;
pub const GL_INDEX_ARRAY_POINTER_EXT: u32 = 32913;
pub const GL_TEXTURE_COORD_ARRAY_POINTER_EXT: u32 = 32914;
pub const GL_EDGE_FLAG_ARRAY_POINTER_EXT: u32 = 32915;
pub const GL_DOUBLE_EXT: u32 = 5130;
pub const GL_BGR_EXT: u32 = 32992;
pub const GL_BGRA_EXT: u32 = 32993;
pub const GL_COLOR_TABLE_FORMAT_EXT: u32 = 32984;
pub const GL_COLOR_TABLE_WIDTH_EXT: u32 = 32985;
pub const GL_COLOR_TABLE_RED_SIZE_EXT: u32 = 32986;
pub const GL_COLOR_TABLE_GREEN_SIZE_EXT: u32 = 32987;
pub const GL_COLOR_TABLE_BLUE_SIZE_EXT: u32 = 32988;
pub const GL_COLOR_TABLE_ALPHA_SIZE_EXT: u32 = 32989;
pub const GL_COLOR_TABLE_LUMINANCE_SIZE_EXT: u32 = 32990;
pub const GL_COLOR_TABLE_INTENSITY_SIZE_EXT: u32 = 32991;
pub const GL_COLOR_INDEX1_EXT: u32 = 32994;
pub const GL_COLOR_INDEX2_EXT: u32 = 32995;
pub const GL_COLOR_INDEX4_EXT: u32 = 32996;
pub const GL_COLOR_INDEX8_EXT: u32 = 32997;
pub const GL_COLOR_INDEX12_EXT: u32 = 32998;
pub const GL_COLOR_INDEX16_EXT: u32 = 32999;
pub const GL_MAX_ELEMENTS_VERTICES_WIN: u32 = 33000;
pub const GL_MAX_ELEMENTS_INDICES_WIN: u32 = 33001;
pub const GL_PHONG_WIN: u32 = 33002;
pub const GL_PHONG_HINT_WIN: u32 = 33003;
pub const GL_FOG_SPECULAR_TEXTURE_WIN: u32 = 33004;
pub const GL_LOGIC_OP: u32 = 3057;
pub const GL_TEXTURE_COMPONENTS: u32 = 4099;
pub const GLFW_VERSION_MAJOR: u32 = 3;
pub const GLFW_VERSION_MINOR: u32 = 3;
pub const GLFW_VERSION_REVISION: u32 = 2;
pub const GLFW_TRUE: u32 = 1;
pub const GLFW_FALSE: u32 = 0;
pub const GLFW_RELEASE: u32 = 0;
pub const GLFW_PRESS: u32 = 1;
pub const GLFW_REPEAT: u32 = 2;
pub const GLFW_HAT_CENTERED: u32 = 0;
pub const GLFW_HAT_UP: u32 = 1;
pub const GLFW_HAT_RIGHT: u32 = 2;
pub const GLFW_HAT_DOWN: u32 = 4;
pub const GLFW_HAT_LEFT: u32 = 8;
pub const GLFW_HAT_RIGHT_UP: u32 = 3;
pub const GLFW_HAT_RIGHT_DOWN: u32 = 6;
pub const GLFW_HAT_LEFT_UP: u32 = 9;
pub const GLFW_HAT_LEFT_DOWN: u32 = 12;
pub const GLFW_KEY_UNKNOWN: i32 = -1;
pub const GLFW_KEY_SPACE: u32 = 32;
pub const GLFW_KEY_APOSTROPHE: u32 = 39;
pub const GLFW_KEY_COMMA: u32 = 44;
pub const GLFW_KEY_MINUS: u32 = 45;
pub const GLFW_KEY_PERIOD: u32 = 46;
pub const GLFW_KEY_SLASH: u32 = 47;
pub const GLFW_KEY_0: u32 = 48;
pub const GLFW_KEY_1: u32 = 49;
pub const GLFW_KEY_2: u32 = 50;
pub const GLFW_KEY_3: u32 = 51;
pub const GLFW_KEY_4: u32 = 52;
pub const GLFW_KEY_5: u32 = 53;
pub const GLFW_KEY_6: u32 = 54;
pub const GLFW_KEY_7: u32 = 55;
pub const GLFW_KEY_8: u32 = 56;
pub const GLFW_KEY_9: u32 = 57;
pub const GLFW_KEY_SEMICOLON: u32 = 59;
pub const GLFW_KEY_EQUAL: u32 = 61;
pub const GLFW_KEY_A: u32 = 65;
pub const GLFW_KEY_B: u32 = 66;
pub const GLFW_KEY_C: u32 = 67;
pub const GLFW_KEY_D: u32 = 68;
pub const GLFW_KEY_E: u32 = 69;
pub const GLFW_KEY_F: u32 = 70;
pub const GLFW_KEY_G: u32 = 71;
pub const GLFW_KEY_H: u32 = 72;
pub const GLFW_KEY_I: u32 = 73;
pub const GLFW_KEY_J: u32 = 74;
pub const GLFW_KEY_K: u32 = 75;
pub const GLFW_KEY_L: u32 = 76;
pub const GLFW_KEY_M: u32 = 77;
pub const GLFW_KEY_N: u32 = 78;
pub const GLFW_KEY_O: u32 = 79;
pub const GLFW_KEY_P: u32 = 80;
pub const GLFW_KEY_Q: u32 = 81;
pub const GLFW_KEY_R: u32 = 82;
pub const GLFW_KEY_S: u32 = 83;
pub const GLFW_KEY_T: u32 = 84;
pub const GLFW_KEY_U: u32 = 85;
pub const GLFW_KEY_V: u32 = 86;
pub const GLFW_KEY_W: u32 = 87;
pub const GLFW_KEY_X: u32 = 88;
pub const GLFW_KEY_Y: u32 = 89;
pub const GLFW_KEY_Z: u32 = 90;
pub const GLFW_KEY_LEFT_BRACKET: u32 = 91;
pub const GLFW_KEY_BACKSLASH: u32 = 92;
pub const GLFW_KEY_RIGHT_BRACKET: u32 = 93;
pub const GLFW_KEY_GRAVE_ACCENT: u32 = 96;
pub const GLFW_KEY_WORLD_1: u32 = 161;
pub const GLFW_KEY_WORLD_2: u32 = 162;
pub const GLFW_KEY_ESCAPE: u32 = 256;
pub const GLFW_KEY_ENTER: u32 = 257;
pub const GLFW_KEY_TAB: u32 = 258;
pub const GLFW_KEY_BACKSPACE: u32 = 259;
pub const GLFW_KEY_INSERT: u32 = 260;
pub const GLFW_KEY_DELETE: u32 = 261;
pub const GLFW_KEY_RIGHT: u32 = 262;
pub const GLFW_KEY_LEFT: u32 = 263;
pub const GLFW_KEY_DOWN: u32 = 264;
pub const GLFW_KEY_UP: u32 = 265;
pub const GLFW_KEY_PAGE_UP: u32 = 266;
pub const GLFW_KEY_PAGE_DOWN: u32 = 267;
pub const GLFW_KEY_HOME: u32 = 268;
pub const GLFW_KEY_END: u32 = 269;
pub const GLFW_KEY_CAPS_LOCK: u32 = 280;
pub const GLFW_KEY_SCROLL_LOCK: u32 = 281;
pub const GLFW_KEY_NUM_LOCK: u32 = 282;
pub const GLFW_KEY_PRINT_SCREEN: u32 = 283;
pub const GLFW_KEY_PAUSE: u32 = 284;
pub const GLFW_KEY_F1: u32 = 290;
pub const GLFW_KEY_F2: u32 = 291;
pub const GLFW_KEY_F3: u32 = 292;
pub const GLFW_KEY_F4: u32 = 293;
pub const GLFW_KEY_F5: u32 = 294;
pub const GLFW_KEY_F6: u32 = 295;
pub const GLFW_KEY_F7: u32 = 296;
pub const GLFW_KEY_F8: u32 = 297;
pub const GLFW_KEY_F9: u32 = 298;
pub const GLFW_KEY_F10: u32 = 299;
pub const GLFW_KEY_F11: u32 = 300;
pub const GLFW_KEY_F12: u32 = 301;
pub const GLFW_KEY_F13: u32 = 302;
pub const GLFW_KEY_F14: u32 = 303;
pub const GLFW_KEY_F15: u32 = 304;
pub const GLFW_KEY_F16: u32 = 305;
pub const GLFW_KEY_F17: u32 = 306;
pub const GLFW_KEY_F18: u32 = 307;
pub const GLFW_KEY_F19: u32 = 308;
pub const GLFW_KEY_F20: u32 = 309;
pub const GLFW_KEY_F21: u32 = 310;
pub const GLFW_KEY_F22: u32 = 311;
pub const GLFW_KEY_F23: u32 = 312;
pub const GLFW_KEY_F24: u32 = 313;
pub const GLFW_KEY_F25: u32 = 314;
pub const GLFW_KEY_KP_0: u32 = 320;
pub const GLFW_KEY_KP_1: u32 = 321;
pub const GLFW_KEY_KP_2: u32 = 322;
pub const GLFW_KEY_KP_3: u32 = 323;
pub const GLFW_KEY_KP_4: u32 = 324;
pub const GLFW_KEY_KP_5: u32 = 325;
pub const GLFW_KEY_KP_6: u32 = 326;
pub const GLFW_KEY_KP_7: u32 = 327;
pub const GLFW_KEY_KP_8: u32 = 328;
pub const GLFW_KEY_KP_9: u32 = 329;
pub const GLFW_KEY_KP_DECIMAL: u32 = 330;
pub const GLFW_KEY_KP_DIVIDE: u32 = 331;
pub const GLFW_KEY_KP_MULTIPLY: u32 = 332;
pub const GLFW_KEY_KP_SUBTRACT: u32 = 333;
pub const GLFW_KEY_KP_ADD: u32 = 334;
pub const GLFW_KEY_KP_ENTER: u32 = 335;
pub const GLFW_KEY_KP_EQUAL: u32 = 336;
pub const GLFW_KEY_LEFT_SHIFT: u32 = 340;
pub const GLFW_KEY_LEFT_CONTROL: u32 = 341;
pub const GLFW_KEY_LEFT_ALT: u32 = 342;
pub const GLFW_KEY_LEFT_SUPER: u32 = 343;
pub const GLFW_KEY_RIGHT_SHIFT: u32 = 344;
pub const GLFW_KEY_RIGHT_CONTROL: u32 = 345;
pub const GLFW_KEY_RIGHT_ALT: u32 = 346;
pub const GLFW_KEY_RIGHT_SUPER: u32 = 347;
pub const GLFW_KEY_MENU: u32 = 348;
pub const GLFW_KEY_LAST: u32 = 348;
pub const GLFW_MOD_SHIFT: u32 = 1;
pub const GLFW_MOD_CONTROL: u32 = 2;
pub const GLFW_MOD_ALT: u32 = 4;
pub const GLFW_MOD_SUPER: u32 = 8;
pub const GLFW_MOD_CAPS_LOCK: u32 = 16;
pub const GLFW_MOD_NUM_LOCK: u32 = 32;
pub const GLFW_MOUSE_BUTTON_1: u32 = 0;
pub const GLFW_MOUSE_BUTTON_2: u32 = 1;
pub const GLFW_MOUSE_BUTTON_3: u32 = 2;
pub const GLFW_MOUSE_BUTTON_4: u32 = 3;
pub const GLFW_MOUSE_BUTTON_5: u32 = 4;
pub const GLFW_MOUSE_BUTTON_6: u32 = 5;
pub const GLFW_MOUSE_BUTTON_7: u32 = 6;
pub const GLFW_MOUSE_BUTTON_8: u32 = 7;
pub const GLFW_MOUSE_BUTTON_LAST: u32 = 7;
pub const GLFW_MOUSE_BUTTON_LEFT: u32 = 0;
pub const GLFW_MOUSE_BUTTON_RIGHT: u32 = 1;
pub const GLFW_MOUSE_BUTTON_MIDDLE: u32 = 2;
pub const GLFW_JOYSTICK_1: u32 = 0;
pub const GLFW_JOYSTICK_2: u32 = 1;
pub const GLFW_JOYSTICK_3: u32 = 2;
pub const GLFW_JOYSTICK_4: u32 = 3;
pub const GLFW_JOYSTICK_5: u32 = 4;
pub const GLFW_JOYSTICK_6: u32 = 5;
pub const GLFW_JOYSTICK_7: u32 = 6;
pub const GLFW_JOYSTICK_8: u32 = 7;
pub const GLFW_JOYSTICK_9: u32 = 8;
pub const GLFW_JOYSTICK_10: u32 = 9;
pub const GLFW_JOYSTICK_11: u32 = 10;
pub const GLFW_JOYSTICK_12: u32 = 11;
pub const GLFW_JOYSTICK_13: u32 = 12;
pub const GLFW_JOYSTICK_14: u32 = 13;
pub const GLFW_JOYSTICK_15: u32 = 14;
pub const GLFW_JOYSTICK_16: u32 = 15;
pub const GLFW_JOYSTICK_LAST: u32 = 15;
pub const GLFW_GAMEPAD_BUTTON_A: u32 = 0;
pub const GLFW_GAMEPAD_BUTTON_B: u32 = 1;
pub const GLFW_GAMEPAD_BUTTON_X: u32 = 2;
pub const GLFW_GAMEPAD_BUTTON_Y: u32 = 3;
pub const GLFW_GAMEPAD_BUTTON_LEFT_BUMPER: u32 = 4;
pub const GLFW_GAMEPAD_BUTTON_RIGHT_BUMPER: u32 = 5;
pub const GLFW_GAMEPAD_BUTTON_BACK: u32 = 6;
pub const GLFW_GAMEPAD_BUTTON_START: u32 = 7;
pub const GLFW_GAMEPAD_BUTTON_GUIDE: u32 = 8;
pub const GLFW_GAMEPAD_BUTTON_LEFT_THUMB: u32 = 9;
pub const GLFW_GAMEPAD_BUTTON_RIGHT_THUMB: u32 = 10;
pub const GLFW_GAMEPAD_BUTTON_DPAD_UP: u32 = 11;
pub const GLFW_GAMEPAD_BUTTON_DPAD_RIGHT: u32 = 12;
pub const GLFW_GAMEPAD_BUTTON_DPAD_DOWN: u32 = 13;
pub const GLFW_GAMEPAD_BUTTON_DPAD_LEFT: u32 = 14;
pub const GLFW_GAMEPAD_BUTTON_LAST: u32 = 14;
pub const GLFW_GAMEPAD_BUTTON_CROSS: u32 = 0;
pub const GLFW_GAMEPAD_BUTTON_CIRCLE: u32 = 1;
pub const GLFW_GAMEPAD_BUTTON_SQUARE: u32 = 2;
pub const GLFW_GAMEPAD_BUTTON_TRIANGLE: u32 = 3;
pub const GLFW_GAMEPAD_AXIS_LEFT_X: u32 = 0;
pub const GLFW_GAMEPAD_AXIS_LEFT_Y: u32 = 1;
pub const GLFW_GAMEPAD_AXIS_RIGHT_X: u32 = 2;
pub const GLFW_GAMEPAD_AXIS_RIGHT_Y: u32 = 3;
pub const GLFW_GAMEPAD_AXIS_LEFT_TRIGGER: u32 = 4;
pub const GLFW_GAMEPAD_AXIS_RIGHT_TRIGGER: u32 = 5;
pub const GLFW_GAMEPAD_AXIS_LAST: u32 = 5;
pub const GLFW_NO_ERROR: u32 = 0;
pub const GLFW_NOT_INITIALIZED: u32 = 65537;
pub const GLFW_NO_CURRENT_CONTEXT: u32 = 65538;
pub const GLFW_INVALID_ENUM: u32 = 65539;
pub const GLFW_INVALID_VALUE: u32 = 65540;
pub const GLFW_OUT_OF_MEMORY: u32 = 65541;
pub const GLFW_API_UNAVAILABLE: u32 = 65542;
pub const GLFW_VERSION_UNAVAILABLE: u32 = 65543;
pub const GLFW_PLATFORM_ERROR: u32 = 65544;
pub const GLFW_FORMAT_UNAVAILABLE: u32 = 65545;
pub const GLFW_NO_WINDOW_CONTEXT: u32 = 65546;
pub const GLFW_FOCUSED: u32 = 131073;
pub const GLFW_ICONIFIED: u32 = 131074;
pub const GLFW_RESIZABLE: u32 = 131075;
pub const GLFW_VISIBLE: u32 = 131076;
pub const GLFW_DECORATED: u32 = 131077;
pub const GLFW_AUTO_ICONIFY: u32 = 131078;
pub const GLFW_FLOATING: u32 = 131079;
pub const GLFW_MAXIMIZED: u32 = 131080;
pub const GLFW_CENTER_CURSOR: u32 = 131081;
pub const GLFW_TRANSPARENT_FRAMEBUFFER: u32 = 131082;
pub const GLFW_HOVERED: u32 = 131083;
pub const GLFW_FOCUS_ON_SHOW: u32 = 131084;
pub const GLFW_RED_BITS: u32 = 135169;
pub const GLFW_GREEN_BITS: u32 = 135170;
pub const GLFW_BLUE_BITS: u32 = 135171;
pub const GLFW_ALPHA_BITS: u32 = 135172;
pub const GLFW_DEPTH_BITS: u32 = 135173;
pub const GLFW_STENCIL_BITS: u32 = 135174;
pub const GLFW_ACCUM_RED_BITS: u32 = 135175;
pub const GLFW_ACCUM_GREEN_BITS: u32 = 135176;
pub const GLFW_ACCUM_BLUE_BITS: u32 = 135177;
pub const GLFW_ACCUM_ALPHA_BITS: u32 = 135178;
pub const GLFW_AUX_BUFFERS: u32 = 135179;
pub const GLFW_STEREO: u32 = 135180;
pub const GLFW_SAMPLES: u32 = 135181;
pub const GLFW_SRGB_CAPABLE: u32 = 135182;
pub const GLFW_REFRESH_RATE: u32 = 135183;
pub const GLFW_DOUBLEBUFFER: u32 = 135184;
pub const GLFW_CLIENT_API: u32 = 139265;
pub const GLFW_CONTEXT_VERSION_MAJOR: u32 = 139266;
pub const GLFW_CONTEXT_VERSION_MINOR: u32 = 139267;
pub const GLFW_CONTEXT_REVISION: u32 = 139268;
pub const GLFW_CONTEXT_ROBUSTNESS: u32 = 139269;
pub const GLFW_OPENGL_FORWARD_COMPAT: u32 = 139270;
pub const GLFW_OPENGL_DEBUG_CONTEXT: u32 = 139271;
pub const GLFW_OPENGL_PROFILE: u32 = 139272;
pub const GLFW_CONTEXT_RELEASE_BEHAVIOR: u32 = 139273;
pub const GLFW_CONTEXT_NO_ERROR: u32 = 139274;
pub const GLFW_CONTEXT_CREATION_API: u32 = 139275;
pub const GLFW_SCALE_TO_MONITOR: u32 = 139276;
pub const GLFW_COCOA_RETINA_FRAMEBUFFER: u32 = 143361;
pub const GLFW_COCOA_FRAME_NAME: u32 = 143362;
pub const GLFW_COCOA_GRAPHICS_SWITCHING: u32 = 143363;
pub const GLFW_X11_CLASS_NAME: u32 = 147457;
pub const GLFW_X11_INSTANCE_NAME: u32 = 147458;
pub const GLFW_NO_API: u32 = 0;
pub const GLFW_OPENGL_API: u32 = 196609;
pub const GLFW_OPENGL_ES_API: u32 = 196610;
pub const GLFW_NO_ROBUSTNESS: u32 = 0;
pub const GLFW_NO_RESET_NOTIFICATION: u32 = 200705;
pub const GLFW_LOSE_CONTEXT_ON_RESET: u32 = 200706;
pub const GLFW_OPENGL_ANY_PROFILE: u32 = 0;
pub const GLFW_OPENGL_CORE_PROFILE: u32 = 204801;
pub const GLFW_OPENGL_COMPAT_PROFILE: u32 = 204802;
pub const GLFW_CURSOR: u32 = 208897;
pub const GLFW_STICKY_KEYS: u32 = 208898;
pub const GLFW_STICKY_MOUSE_BUTTONS: u32 = 208899;
pub const GLFW_LOCK_KEY_MODS: u32 = 208900;
pub const GLFW_RAW_MOUSE_MOTION: u32 = 208901;
pub const GLFW_CURSOR_NORMAL: u32 = 212993;
pub const GLFW_CURSOR_HIDDEN: u32 = 212994;
pub const GLFW_CURSOR_DISABLED: u32 = 212995;
pub const GLFW_ANY_RELEASE_BEHAVIOR: u32 = 0;
pub const GLFW_RELEASE_BEHAVIOR_FLUSH: u32 = 217089;
pub const GLFW_RELEASE_BEHAVIOR_NONE: u32 = 217090;
pub const GLFW_NATIVE_CONTEXT_API: u32 = 221185;
pub const GLFW_EGL_CONTEXT_API: u32 = 221186;
pub const GLFW_OSMESA_CONTEXT_API: u32 = 221187;
pub const GLFW_ARROW_CURSOR: u32 = 221185;
pub const GLFW_IBEAM_CURSOR: u32 = 221186;
pub const GLFW_CROSSHAIR_CURSOR: u32 = 221187;
pub const GLFW_HAND_CURSOR: u32 = 221188;
pub const GLFW_HRESIZE_CURSOR: u32 = 221189;
pub const GLFW_VRESIZE_CURSOR: u32 = 221190;
pub const GLFW_CONNECTED: u32 = 262145;
pub const GLFW_DISCONNECTED: u32 = 262146;
pub const GLFW_JOYSTICK_HAT_BUTTONS: u32 = 327681;
pub const GLFW_COCOA_CHDIR_RESOURCES: u32 = 331777;
pub const GLFW_COCOA_MENUBAR: u32 = 331778;
pub const GLFW_DONT_CARE: i32 = -1;
pub type size_t = ::std::os::raw::c_ulonglong;
pub type wchar_t = ::std::os::raw::c_ushort;
pub type max_align_t = f64;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type GLenum = ::std::os::raw::c_uint;
pub type GLboolean = ::std::os::raw::c_uchar;
pub type GLbitfield = ::std::os::raw::c_uint;
pub type GLbyte = ::std::os::raw::c_schar;
pub type GLshort = ::std::os::raw::c_short;
pub type GLint = ::std::os::raw::c_int;
pub type GLsizei = ::std::os::raw::c_int;
pub type GLubyte = ::std::os::raw::c_uchar;
pub type GLushort = ::std::os::raw::c_ushort;
pub type GLuint = ::std::os::raw::c_uint;
pub type GLfloat = f32;
pub type GLclampf = f32;
pub type GLdouble = f64;
pub type GLclampd = f64;
pub type GLvoid = ::std::os::raw::c_void;
extern "C" {
    pub fn glAccum(op: GLenum, value: GLfloat);
}
extern "C" {
    pub fn glAlphaFunc(func: GLenum, ref_: GLclampf);
}
extern "C" {
    pub fn glAreTexturesResident(
        n: GLsizei,
        textures: *const GLuint,
        residences: *mut GLboolean,
    ) -> GLboolean;
}
extern "C" {
    pub fn glArrayElement(i: GLint);
}
extern "C" {
    pub fn glBegin(mode: GLenum);
}
extern "C" {
    pub fn glBindTexture(target: GLenum, texture: GLuint);
}
extern "C" {
    pub fn glBitmap(
        width: GLsizei,
        height: GLsizei,
        xorig: GLfloat,
        yorig: GLfloat,
        xmove: GLfloat,
        ymove: GLfloat,
        bitmap: *const GLubyte,
    );
}
extern "C" {
    pub fn glBlendFunc(sfactor: GLenum, dfactor: GLenum);
}
extern "C" {
    pub fn glCallList(list: GLuint);
}
extern "C" {
    pub fn glCallLists(n: GLsizei, type_: GLenum, lists: *const GLvoid);
}
extern "C" {
    pub fn glClear(mask: GLbitfield);
}
extern "C" {
    pub fn glClearAccum(red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat);
}
extern "C" {
    pub fn glClearColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf);
}
extern "C" {
    pub fn glClearDepth(depth: GLclampd);
}
extern "C" {
    pub fn glClearIndex(c: GLfloat);
}
extern "C" {
    pub fn glClearStencil(s: GLint);
}
extern "C" {
    pub fn glClipPlane(plane: GLenum, equation: *const GLdouble);
}
extern "C" {
    pub fn glColor3b(red: GLbyte, green: GLbyte, blue: GLbyte);
}
extern "C" {
    pub fn glColor3bv(v: *const GLbyte);
}
extern "C" {
    pub fn glColor3d(red: GLdouble, green: GLdouble, blue: GLdouble);
}
extern "C" {
    pub fn glColor3dv(v: *const GLdouble);
}
extern "C" {
    pub fn glColor3f(red: GLfloat, green: GLfloat, blue: GLfloat);
}
extern "C" {
    pub fn glColor3fv(v: *const GLfloat);
}
extern "C" {
    pub fn glColor3i(red: GLint, green: GLint, blue: GLint);
}
extern "C" {
    pub fn glColor3iv(v: *const GLint);
}
extern "C" {
    pub fn glColor3s(red: GLshort, green: GLshort, blue: GLshort);
}
extern "C" {
    pub fn glColor3sv(v: *const GLshort);
}
extern "C" {
    pub fn glColor3ub(red: GLubyte, green: GLubyte, blue: GLubyte);
}
extern "C" {
    pub fn glColor3ubv(v: *const GLubyte);
}
extern "C" {
    pub fn glColor3ui(red: GLuint, green: GLuint, blue: GLuint);
}
extern "C" {
    pub fn glColor3uiv(v: *const GLuint);
}
extern "C" {
    pub fn glColor3us(red: GLushort, green: GLushort, blue: GLushort);
}
extern "C" {
    pub fn glColor3usv(v: *const GLushort);
}
extern "C" {
    pub fn glColor4b(red: GLbyte, green: GLbyte, blue: GLbyte, alpha: GLbyte);
}
extern "C" {
    pub fn glColor4bv(v: *const GLbyte);
}
extern "C" {
    pub fn glColor4d(red: GLdouble, green: GLdouble, blue: GLdouble, alpha: GLdouble);
}
extern "C" {
    pub fn glColor4dv(v: *const GLdouble);
}
extern "C" {
    pub fn glColor4f(red: GLfloat, green: GLfloat, blue: GLfloat, alpha: GLfloat);
}
extern "C" {
    pub fn glColor4fv(v: *const GLfloat);
}
extern "C" {
    pub fn glColor4i(red: GLint, green: GLint, blue: GLint, alpha: GLint);
}
extern "C" {
    pub fn glColor4iv(v: *const GLint);
}
extern "C" {
    pub fn glColor4s(red: GLshort, green: GLshort, blue: GLshort, alpha: GLshort);
}
extern "C" {
    pub fn glColor4sv(v: *const GLshort);
}
extern "C" {
    pub fn glColor4ub(red: GLubyte, green: GLubyte, blue: GLubyte, alpha: GLubyte);
}
extern "C" {
    pub fn glColor4ubv(v: *const GLubyte);
}
extern "C" {
    pub fn glColor4ui(red: GLuint, green: GLuint, blue: GLuint, alpha: GLuint);
}
extern "C" {
    pub fn glColor4uiv(v: *const GLuint);
}
extern "C" {
    pub fn glColor4us(red: GLushort, green: GLushort, blue: GLushort, alpha: GLushort);
}
extern "C" {
    pub fn glColor4usv(v: *const GLushort);
}
extern "C" {
    pub fn glColorMask(red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean);
}
extern "C" {
    pub fn glColorMaterial(face: GLenum, mode: GLenum);
}
extern "C" {
    pub fn glColorPointer(size: GLint, type_: GLenum, stride: GLsizei, pointer: *const GLvoid);
}
extern "C" {
    pub fn glCopyPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, type_: GLenum);
}
extern "C" {
    pub fn glCopyTexImage1D(
        target: GLenum,
        level: GLint,
        internalFormat: GLenum,
        x: GLint,
        y: GLint,
        width: GLsizei,
        border: GLint,
    );
}
extern "C" {
    pub fn glCopyTexImage2D(
        target: GLenum,
        level: GLint,
        internalFormat: GLenum,
        x: GLint,
        y: GLint,
        width: GLsizei,
        height: GLsizei,
        border: GLint,
    );
}
extern "C" {
    pub fn glCopyTexSubImage1D(
        target: GLenum,
        level: GLint,
        xoffset: GLint,
        x: GLint,
        y: GLint,
        width: GLsizei,
    );
}
extern "C" {
    pub fn glCopyTexSubImage2D(
        target: GLenum,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        x: GLint,
        y: GLint,
        width: GLsizei,
        height: GLsizei,
    );
}
extern "C" {
    pub fn glCullFace(mode: GLenum);
}
extern "C" {
    pub fn glDeleteLists(list: GLuint, range: GLsizei);
}
extern "C" {
    pub fn glDeleteTextures(n: GLsizei, textures: *const GLuint);
}
extern "C" {
    pub fn glDepthFunc(func: GLenum);
}
extern "C" {
    pub fn glDepthMask(flag: GLboolean);
}
extern "C" {
    pub fn glDepthRange(zNear: GLclampd, zFar: GLclampd);
}
extern "C" {
    pub fn glDisable(cap: GLenum);
}
extern "C" {
    pub fn glDisableClientState(array: GLenum);
}
extern "C" {
    pub fn glDrawArrays(mode: GLenum, first: GLint, count: GLsizei);
}
extern "C" {
    pub fn glDrawBuffer(mode: GLenum);
}
extern "C" {
    pub fn glDrawElements(mode: GLenum, count: GLsizei, type_: GLenum, indices: *const GLvoid);
}
extern "C" {
    pub fn glDrawPixels(
        width: GLsizei,
        height: GLsizei,
        format: GLenum,
        type_: GLenum,
        pixels: *const GLvoid,
    );
}
extern "C" {
    pub fn glEdgeFlag(flag: GLboolean);
}
extern "C" {
    pub fn glEdgeFlagPointer(stride: GLsizei, pointer: *const GLvoid);
}
extern "C" {
    pub fn glEdgeFlagv(flag: *const GLboolean);
}
extern "C" {
    pub fn glEnable(cap: GLenum);
}
extern "C" {
    pub fn glEnableClientState(array: GLenum);
}
extern "C" {
    pub fn glEnd();
}
extern "C" {
    pub fn glEndList();
}
extern "C" {
    pub fn glEvalCoord1d(u: GLdouble);
}
extern "C" {
    pub fn glEvalCoord1dv(u: *const GLdouble);
}
extern "C" {
    pub fn glEvalCoord1f(u: GLfloat);
}
extern "C" {
    pub fn glEvalCoord1fv(u: *const GLfloat);
}
extern "C" {
    pub fn glEvalCoord2d(u: GLdouble, v: GLdouble);
}
extern "C" {
    pub fn glEvalCoord2dv(u: *const GLdouble);
}
extern "C" {
    pub fn glEvalCoord2f(u: GLfloat, v: GLfloat);
}
extern "C" {
    pub fn glEvalCoord2fv(u: *const GLfloat);
}
extern "C" {
    pub fn glEvalMesh1(mode: GLenum, i1: GLint, i2: GLint);
}
extern "C" {
    pub fn glEvalMesh2(mode: GLenum, i1: GLint, i2: GLint, j1: GLint, j2: GLint);
}
extern "C" {
    pub fn glEvalPoint1(i: GLint);
}
extern "C" {
    pub fn glEvalPoint2(i: GLint, j: GLint);
}
extern "C" {
    pub fn glFeedbackBuffer(size: GLsizei, type_: GLenum, buffer: *mut GLfloat);
}
extern "C" {
    pub fn glFinish();
}
extern "C" {
    pub fn glFlush();
}
extern "C" {
    pub fn glFogf(pname: GLenum, param: GLfloat);
}
extern "C" {
    pub fn glFogfv(pname: GLenum, params: *const GLfloat);
}
extern "C" {
    pub fn glFogi(pname: GLenum, param: GLint);
}
extern "C" {
    pub fn glFogiv(pname: GLenum, params: *const GLint);
}
extern "C" {
    pub fn glFrontFace(mode: GLenum);
}
extern "C" {
    pub fn glFrustum(
        left: GLdouble,
        right: GLdouble,
        bottom: GLdouble,
        top: GLdouble,
        zNear: GLdouble,
        zFar: GLdouble,
    );
}
extern "C" {
    pub fn glGenLists(range: GLsizei) -> GLuint;
}
extern "C" {
    pub fn glGenTextures(n: GLsizei, textures: *mut GLuint);
}
extern "C" {
    pub fn glGetBooleanv(pname: GLenum, params: *mut GLboolean);
}
extern "C" {
    pub fn glGetClipPlane(plane: GLenum, equation: *mut GLdouble);
}
extern "C" {
    pub fn glGetDoublev(pname: GLenum, params: *mut GLdouble);
}
extern "C" {
    pub fn glGetError() -> GLenum;
}
extern "C" {
    pub fn glGetFloatv(pname: GLenum, params: *mut GLfloat);
}
extern "C" {
    pub fn glGetIntegerv(pname: GLenum, params: *mut GLint);
}
extern "C" {
    pub fn glGetLightfv(light: GLenum, pname: GLenum, params: *mut GLfloat);
}
extern "C" {
    pub fn glGetLightiv(light: GLenum, pname: GLenum, params: *mut GLint);
}
extern "C" {
    pub fn glGetMapdv(target: GLenum, query: GLenum, v: *mut GLdouble);
}
extern "C" {
    pub fn glGetMapfv(target: GLenum, query: GLenum, v: *mut GLfloat);
}
extern "C" {
    pub fn glGetMapiv(target: GLenum, query: GLenum, v: *mut GLint);
}
extern "C" {
    pub fn glGetMaterialfv(face: GLenum, pname: GLenum, params: *mut GLfloat);
}
extern "C" {
    pub fn glGetMaterialiv(face: GLenum, pname: GLenum, params: *mut GLint);
}
extern "C" {
    pub fn glGetPixelMapfv(map: GLenum, values: *mut GLfloat);
}
extern "C" {
    pub fn glGetPixelMapuiv(map: GLenum, values: *mut GLuint);
}
extern "C" {
    pub fn glGetPixelMapusv(map: GLenum, values: *mut GLushort);
}
extern "C" {
    pub fn glGetPointerv(pname: GLenum, params: *mut *mut GLvoid);
}
extern "C" {
    pub fn glGetPolygonStipple(mask: *mut GLubyte);
}
extern "C" {
    pub fn glGetString(name: GLenum) -> *const GLubyte;
}
extern "C" {
    pub fn glGetTexEnvfv(target: GLenum, pname: GLenum, params: *mut GLfloat);
}
extern "C" {
    pub fn glGetTexEnviv(target: GLenum, pname: GLenum, params: *mut GLint);
}
extern "C" {
    pub fn glGetTexGendv(coord: GLenum, pname: GLenum, params: *mut GLdouble);
}
extern "C" {
    pub fn glGetTexGenfv(coord: GLenum, pname: GLenum, params: *mut GLfloat);
}
extern "C" {
    pub fn glGetTexGeniv(coord: GLenum, pname: GLenum, params: *mut GLint);
}
extern "C" {
    pub fn glGetTexImage(
        target: GLenum,
        level: GLint,
        format: GLenum,
        type_: GLenum,
        pixels: *mut GLvoid,
    );
}
extern "C" {
    pub fn glGetTexLevelParameterfv(
        target: GLenum,
        level: GLint,
        pname: GLenum,
        params: *mut GLfloat,
    );
}
extern "C" {
    pub fn glGetTexLevelParameteriv(
        target: GLenum,
        level: GLint,
        pname: GLenum,
        params: *mut GLint,
    );
}
extern "C" {
    pub fn glGetTexParameterfv(target: GLenum, pname: GLenum, params: *mut GLfloat);
}
extern "C" {
    pub fn glGetTexParameteriv(target: GLenum, pname: GLenum, params: *mut GLint);
}
extern "C" {
    pub fn glHint(target: GLenum, mode: GLenum);
}
extern "C" {
    pub fn glIndexMask(mask: GLuint);
}
extern "C" {
    pub fn glIndexPointer(type_: GLenum, stride: GLsizei, pointer: *const GLvoid);
}
extern "C" {
    pub fn glIndexd(c: GLdouble);
}
extern "C" {
    pub fn glIndexdv(c: *const GLdouble);
}
extern "C" {
    pub fn glIndexf(c: GLfloat);
}
extern "C" {
    pub fn glIndexfv(c: *const GLfloat);
}
extern "C" {
    pub fn glIndexi(c: GLint);
}
extern "C" {
    pub fn glIndexiv(c: *const GLint);
}
extern "C" {
    pub fn glIndexs(c: GLshort);
}
extern "C" {
    pub fn glIndexsv(c: *const GLshort);
}
extern "C" {
    pub fn glIndexub(c: GLubyte);
}
extern "C" {
    pub fn glIndexubv(c: *const GLubyte);
}
extern "C" {
    pub fn glInitNames();
}
extern "C" {
    pub fn glInterleavedArrays(format: GLenum, stride: GLsizei, pointer: *const GLvoid);
}
extern "C" {
    pub fn glIsEnabled(cap: GLenum) -> GLboolean;
}
extern "C" {
    pub fn glIsList(list: GLuint) -> GLboolean;
}
extern "C" {
    pub fn glIsTexture(texture: GLuint) -> GLboolean;
}
extern "C" {
    pub fn glLightModelf(pname: GLenum, param: GLfloat);
}
extern "C" {
    pub fn glLightModelfv(pname: GLenum, params: *const GLfloat);
}
extern "C" {
    pub fn glLightModeli(pname: GLenum, param: GLint);
}
extern "C" {
    pub fn glLightModeliv(pname: GLenum, params: *const GLint);
}
extern "C" {
    pub fn glLightf(light: GLenum, pname: GLenum, param: GLfloat);
}
extern "C" {
    pub fn glLightfv(light: GLenum, pname: GLenum, params: *const GLfloat);
}
extern "C" {
    pub fn glLighti(light: GLenum, pname: GLenum, param: GLint);
}
extern "C" {
    pub fn glLightiv(light: GLenum, pname: GLenum, params: *const GLint);
}
extern "C" {
    pub fn glLineStipple(factor: GLint, pattern: GLushort);
}
extern "C" {
    pub fn glLineWidth(width: GLfloat);
}
extern "C" {
    pub fn glListBase(base: GLuint);
}
extern "C" {
    pub fn glLoadIdentity();
}
extern "C" {
    pub fn glLoadMatrixd(m: *const GLdouble);
}
extern "C" {
    pub fn glLoadMatrixf(m: *const GLfloat);
}
extern "C" {
    pub fn glLoadName(name: GLuint);
}
extern "C" {
    pub fn glLogicOp(opcode: GLenum);
}
extern "C" {
    pub fn glMap1d(
        target: GLenum,
        u1: GLdouble,
        u2: GLdouble,
        stride: GLint,
        order: GLint,
        points: *const GLdouble,
    );
}
extern "C" {
    pub fn glMap1f(
        target: GLenum,
        u1: GLfloat,
        u2: GLfloat,
        stride: GLint,
        order: GLint,
        points: *const GLfloat,
    );
}
extern "C" {
    pub fn glMap2d(
        target: GLenum,
        u1: GLdouble,
        u2: GLdouble,
        ustride: GLint,
        uorder: GLint,
        v1: GLdouble,
        v2: GLdouble,
        vstride: GLint,
        vorder: GLint,
        points: *const GLdouble,
    );
}
extern "C" {
    pub fn glMap2f(
        target: GLenum,
        u1: GLfloat,
        u2: GLfloat,
        ustride: GLint,
        uorder: GLint,
        v1: GLfloat,
        v2: GLfloat,
        vstride: GLint,
        vorder: GLint,
        points: *const GLfloat,
    );
}
extern "C" {
    pub fn glMapGrid1d(un: GLint, u1: GLdouble, u2: GLdouble);
}
extern "C" {
    pub fn glMapGrid1f(un: GLint, u1: GLfloat, u2: GLfloat);
}
extern "C" {
    pub fn glMapGrid2d(
        un: GLint,
        u1: GLdouble,
        u2: GLdouble,
        vn: GLint,
        v1: GLdouble,
        v2: GLdouble,
    );
}
extern "C" {
    pub fn glMapGrid2f(un: GLint, u1: GLfloat, u2: GLfloat, vn: GLint, v1: GLfloat, v2: GLfloat);
}
extern "C" {
    pub fn glMaterialf(face: GLenum, pname: GLenum, param: GLfloat);
}
extern "C" {
    pub fn glMaterialfv(face: GLenum, pname: GLenum, params: *const GLfloat);
}
extern "C" {
    pub fn glMateriali(face: GLenum, pname: GLenum, param: GLint);
}
extern "C" {
    pub fn glMaterialiv(face: GLenum, pname: GLenum, params: *const GLint);
}
extern "C" {
    pub fn glMatrixMode(mode: GLenum);
}
extern "C" {
    pub fn glMultMatrixd(m: *const GLdouble);
}
extern "C" {
    pub fn glMultMatrixf(m: *const GLfloat);
}
extern "C" {
    pub fn glNewList(list: GLuint, mode: GLenum);
}
extern "C" {
    pub fn glNormal3b(nx: GLbyte, ny: GLbyte, nz: GLbyte);
}
extern "C" {
    pub fn glNormal3bv(v: *const GLbyte);
}
extern "C" {
    pub fn glNormal3d(nx: GLdouble, ny: GLdouble, nz: GLdouble);
}
extern "C" {
    pub fn glNormal3dv(v: *const GLdouble);
}
extern "C" {
    pub fn glNormal3f(nx: GLfloat, ny: GLfloat, nz: GLfloat);
}
extern "C" {
    pub fn glNormal3fv(v: *const GLfloat);
}
extern "C" {
    pub fn glNormal3i(nx: GLint, ny: GLint, nz: GLint);
}
extern "C" {
    pub fn glNormal3iv(v: *const GLint);
}
extern "C" {
    pub fn glNormal3s(nx: GLshort, ny: GLshort, nz: GLshort);
}
extern "C" {
    pub fn glNormal3sv(v: *const GLshort);
}
extern "C" {
    pub fn glNormalPointer(type_: GLenum, stride: GLsizei, pointer: *const GLvoid);
}
extern "C" {
    pub fn glOrtho(
        left: GLdouble,
        right: GLdouble,
        bottom: GLdouble,
        top: GLdouble,
        zNear: GLdouble,
        zFar: GLdouble,
    );
}
extern "C" {
    pub fn glPassThrough(token: GLfloat);
}
extern "C" {
    pub fn glPixelMapfv(map: GLenum, mapsize: GLsizei, values: *const GLfloat);
}
extern "C" {
    pub fn glPixelMapuiv(map: GLenum, mapsize: GLsizei, values: *const GLuint);
}
extern "C" {
    pub fn glPixelMapusv(map: GLenum, mapsize: GLsizei, values: *const GLushort);
}
extern "C" {
    pub fn glPixelStoref(pname: GLenum, param: GLfloat);
}
extern "C" {
    pub fn glPixelStorei(pname: GLenum, param: GLint);
}
extern "C" {
    pub fn glPixelTransferf(pname: GLenum, param: GLfloat);
}
extern "C" {
    pub fn glPixelTransferi(pname: GLenum, param: GLint);
}
extern "C" {
    pub fn glPixelZoom(xfactor: GLfloat, yfactor: GLfloat);
}
extern "C" {
    pub fn glPointSize(size: GLfloat);
}
extern "C" {
    pub fn glPolygonMode(face: GLenum, mode: GLenum);
}
extern "C" {
    pub fn glPolygonOffset(factor: GLfloat, units: GLfloat);
}
extern "C" {
    pub fn glPolygonStipple(mask: *const GLubyte);
}
extern "C" {
    pub fn glPopAttrib();
}
extern "C" {
    pub fn glPopClientAttrib();
}
extern "C" {
    pub fn glPopMatrix();
}
extern "C" {
    pub fn glPopName();
}
extern "C" {
    pub fn glPrioritizeTextures(n: GLsizei, textures: *const GLuint, priorities: *const GLclampf);
}
extern "C" {
    pub fn glPushAttrib(mask: GLbitfield);
}
extern "C" {
    pub fn glPushClientAttrib(mask: GLbitfield);
}
extern "C" {
    pub fn glPushMatrix();
}
extern "C" {
    pub fn glPushName(name: GLuint);
}
extern "C" {
    pub fn glRasterPos2d(x: GLdouble, y: GLdouble);
}
extern "C" {
    pub fn glRasterPos2dv(v: *const GLdouble);
}
extern "C" {
    pub fn glRasterPos2f(x: GLfloat, y: GLfloat);
}
extern "C" {
    pub fn glRasterPos2fv(v: *const GLfloat);
}
extern "C" {
    pub fn glRasterPos2i(x: GLint, y: GLint);
}
extern "C" {
    pub fn glRasterPos2iv(v: *const GLint);
}
extern "C" {
    pub fn glRasterPos2s(x: GLshort, y: GLshort);
}
extern "C" {
    pub fn glRasterPos2sv(v: *const GLshort);
}
extern "C" {
    pub fn glRasterPos3d(x: GLdouble, y: GLdouble, z: GLdouble);
}
extern "C" {
    pub fn glRasterPos3dv(v: *const GLdouble);
}
extern "C" {
    pub fn glRasterPos3f(x: GLfloat, y: GLfloat, z: GLfloat);
}
extern "C" {
    pub fn glRasterPos3fv(v: *const GLfloat);
}
extern "C" {
    pub fn glRasterPos3i(x: GLint, y: GLint, z: GLint);
}
extern "C" {
    pub fn glRasterPos3iv(v: *const GLint);
}
extern "C" {
    pub fn glRasterPos3s(x: GLshort, y: GLshort, z: GLshort);
}
extern "C" {
    pub fn glRasterPos3sv(v: *const GLshort);
}
extern "C" {
    pub fn glRasterPos4d(x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble);
}
extern "C" {
    pub fn glRasterPos4dv(v: *const GLdouble);
}
extern "C" {
    pub fn glRasterPos4f(x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat);
}
extern "C" {
    pub fn glRasterPos4fv(v: *const GLfloat);
}
extern "C" {
    pub fn glRasterPos4i(x: GLint, y: GLint, z: GLint, w: GLint);
}
extern "C" {
    pub fn glRasterPos4iv(v: *const GLint);
}
extern "C" {
    pub fn glRasterPos4s(x: GLshort, y: GLshort, z: GLshort, w: GLshort);
}
extern "C" {
    pub fn glRasterPos4sv(v: *const GLshort);
}
extern "C" {
    pub fn glReadBuffer(mode: GLenum);
}
extern "C" {
    pub fn glReadPixels(
        x: GLint,
        y: GLint,
        width: GLsizei,
        height: GLsizei,
        format: GLenum,
        type_: GLenum,
        pixels: *mut GLvoid,
    );
}
extern "C" {
    pub fn glRectd(x1: GLdouble, y1: GLdouble, x2: GLdouble, y2: GLdouble);
}
extern "C" {
    pub fn glRectdv(v1: *const GLdouble, v2: *const GLdouble);
}
extern "C" {
    pub fn glRectf(x1: GLfloat, y1: GLfloat, x2: GLfloat, y2: GLfloat);
}
extern "C" {
    pub fn glRectfv(v1: *const GLfloat, v2: *const GLfloat);
}
extern "C" {
    pub fn glRecti(x1: GLint, y1: GLint, x2: GLint, y2: GLint);
}
extern "C" {
    pub fn glRectiv(v1: *const GLint, v2: *const GLint);
}
extern "C" {
    pub fn glRects(x1: GLshort, y1: GLshort, x2: GLshort, y2: GLshort);
}
extern "C" {
    pub fn glRectsv(v1: *const GLshort, v2: *const GLshort);
}
extern "C" {
    pub fn glRenderMode(mode: GLenum) -> GLint;
}
extern "C" {
    pub fn glRotated(angle: GLdouble, x: GLdouble, y: GLdouble, z: GLdouble);
}
extern "C" {
    pub fn glRotatef(angle: GLfloat, x: GLfloat, y: GLfloat, z: GLfloat);
}
extern "C" {
    pub fn glScaled(x: GLdouble, y: GLdouble, z: GLdouble);
}
extern "C" {
    pub fn glScalef(x: GLfloat, y: GLfloat, z: GLfloat);
}
extern "C" {
    pub fn glScissor(x: GLint, y: GLint, width: GLsizei, height: GLsizei);
}
extern "C" {
    pub fn glSelectBuffer(size: GLsizei, buffer: *mut GLuint);
}
extern "C" {
    pub fn glShadeModel(mode: GLenum);
}
extern "C" {
    pub fn glStencilFunc(func: GLenum, ref_: GLint, mask: GLuint);
}
extern "C" {
    pub fn glStencilMask(mask: GLuint);
}
extern "C" {
    pub fn glStencilOp(fail: GLenum, zfail: GLenum, zpass: GLenum);
}
extern "C" {
    pub fn glTexCoord1d(s: GLdouble);
}
extern "C" {
    pub fn glTexCoord1dv(v: *const GLdouble);
}
extern "C" {
    pub fn glTexCoord1f(s: GLfloat);
}
extern "C" {
    pub fn glTexCoord1fv(v: *const GLfloat);
}
extern "C" {
    pub fn glTexCoord1i(s: GLint);
}
extern "C" {
    pub fn glTexCoord1iv(v: *const GLint);
}
extern "C" {
    pub fn glTexCoord1s(s: GLshort);
}
extern "C" {
    pub fn glTexCoord1sv(v: *const GLshort);
}
extern "C" {
    pub fn glTexCoord2d(s: GLdouble, t: GLdouble);
}
extern "C" {
    pub fn glTexCoord2dv(v: *const GLdouble);
}
extern "C" {
    pub fn glTexCoord2f(s: GLfloat, t: GLfloat);
}
extern "C" {
    pub fn glTexCoord2fv(v: *const GLfloat);
}
extern "C" {
    pub fn glTexCoord2i(s: GLint, t: GLint);
}
extern "C" {
    pub fn glTexCoord2iv(v: *const GLint);
}
extern "C" {
    pub fn glTexCoord2s(s: GLshort, t: GLshort);
}
extern "C" {
    pub fn glTexCoord2sv(v: *const GLshort);
}
extern "C" {
    pub fn glTexCoord3d(s: GLdouble, t: GLdouble, r: GLdouble);
}
extern "C" {
    pub fn glTexCoord3dv(v: *const GLdouble);
}
extern "C" {
    pub fn glTexCoord3f(s: GLfloat, t: GLfloat, r: GLfloat);
}
extern "C" {
    pub fn glTexCoord3fv(v: *const GLfloat);
}
extern "C" {
    pub fn glTexCoord3i(s: GLint, t: GLint, r: GLint);
}
extern "C" {
    pub fn glTexCoord3iv(v: *const GLint);
}
extern "C" {
    pub fn glTexCoord3s(s: GLshort, t: GLshort, r: GLshort);
}
extern "C" {
    pub fn glTexCoord3sv(v: *const GLshort);
}
extern "C" {
    pub fn glTexCoord4d(s: GLdouble, t: GLdouble, r: GLdouble, q: GLdouble);
}
extern "C" {
    pub fn glTexCoord4dv(v: *const GLdouble);
}
extern "C" {
    pub fn glTexCoord4f(s: GLfloat, t: GLfloat, r: GLfloat, q: GLfloat);
}
extern "C" {
    pub fn glTexCoord4fv(v: *const GLfloat);
}
extern "C" {
    pub fn glTexCoord4i(s: GLint, t: GLint, r: GLint, q: GLint);
}
extern "C" {
    pub fn glTexCoord4iv(v: *const GLint);
}
extern "C" {
    pub fn glTexCoord4s(s: GLshort, t: GLshort, r: GLshort, q: GLshort);
}
extern "C" {
    pub fn glTexCoord4sv(v: *const GLshort);
}
extern "C" {
    pub fn glTexCoordPointer(size: GLint, type_: GLenum, stride: GLsizei, pointer: *const GLvoid);
}
extern "C" {
    pub fn glTexEnvf(target: GLenum, pname: GLenum, param: GLfloat);
}
extern "C" {
    pub fn glTexEnvfv(target: GLenum, pname: GLenum, params: *const GLfloat);
}
extern "C" {
    pub fn glTexEnvi(target: GLenum, pname: GLenum, param: GLint);
}
extern "C" {
    pub fn glTexEnviv(target: GLenum, pname: GLenum, params: *const GLint);
}
extern "C" {
    pub fn glTexGend(coord: GLenum, pname: GLenum, param: GLdouble);
}
extern "C" {
    pub fn glTexGendv(coord: GLenum, pname: GLenum, params: *const GLdouble);
}
extern "C" {
    pub fn glTexGenf(coord: GLenum, pname: GLenum, param: GLfloat);
}
extern "C" {
    pub fn glTexGenfv(coord: GLenum, pname: GLenum, params: *const GLfloat);
}
extern "C" {
    pub fn glTexGeni(coord: GLenum, pname: GLenum, param: GLint);
}
extern "C" {
    pub fn glTexGeniv(coord: GLenum, pname: GLenum, params: *const GLint);
}
extern "C" {
    pub fn glTexImage1D(
        target: GLenum,
        level: GLint,
        internalformat: GLint,
        width: GLsizei,
        border: GLint,
        format: GLenum,
        type_: GLenum,
        pixels: *const GLvoid,
    );
}
extern "C" {
    pub fn glTexImage2D(
        target: GLenum,
        level: GLint,
        internalformat: GLint,
        width: GLsizei,
        height: GLsizei,
        border: GLint,
        format: GLenum,
        type_: GLenum,
        pixels: *const GLvoid,
    );
}
extern "C" {
    pub fn glTexParameterf(target: GLenum, pname: GLenum, param: GLfloat);
}
extern "C" {
    pub fn glTexParameterfv(target: GLenum, pname: GLenum, params: *const GLfloat);
}
extern "C" {
    pub fn glTexParameteri(target: GLenum, pname: GLenum, param: GLint);
}
extern "C" {
    pub fn glTexParameteriv(target: GLenum, pname: GLenum, params: *const GLint);
}
extern "C" {
    pub fn glTexSubImage1D(
        target: GLenum,
        level: GLint,
        xoffset: GLint,
        width: GLsizei,
        format: GLenum,
        type_: GLenum,
        pixels: *const GLvoid,
    );
}
extern "C" {
    pub fn glTexSubImage2D(
        target: GLenum,
        level: GLint,
        xoffset: GLint,
        yoffset: GLint,
        width: GLsizei,
        height: GLsizei,
        format: GLenum,
        type_: GLenum,
        pixels: *const GLvoid,
    );
}
extern "C" {
    pub fn glTranslated(x: GLdouble, y: GLdouble, z: GLdouble);
}
extern "C" {
    pub fn glTranslatef(x: GLfloat, y: GLfloat, z: GLfloat);
}
extern "C" {
    pub fn glVertex2d(x: GLdouble, y: GLdouble);
}
extern "C" {
    pub fn glVertex2dv(v: *const GLdouble);
}
extern "C" {
    pub fn glVertex2f(x: GLfloat, y: GLfloat);
}
extern "C" {
    pub fn glVertex2fv(v: *const GLfloat);
}
extern "C" {
    pub fn glVertex2i(x: GLint, y: GLint);
}
extern "C" {
    pub fn glVertex2iv(v: *const GLint);
}
extern "C" {
    pub fn glVertex2s(x: GLshort, y: GLshort);
}
extern "C" {
    pub fn glVertex2sv(v: *const GLshort);
}
extern "C" {
    pub fn glVertex3d(x: GLdouble, y: GLdouble, z: GLdouble);
}
extern "C" {
    pub fn glVertex3dv(v: *const GLdouble);
}
extern "C" {
    pub fn glVertex3f(x: GLfloat, y: GLfloat, z: GLfloat);
}
extern "C" {
    pub fn glVertex3fv(v: *const GLfloat);
}
extern "C" {
    pub fn glVertex3i(x: GLint, y: GLint, z: GLint);
}
extern "C" {
    pub fn glVertex3iv(v: *const GLint);
}
extern "C" {
    pub fn glVertex3s(x: GLshort, y: GLshort, z: GLshort);
}
extern "C" {
    pub fn glVertex3sv(v: *const GLshort);
}
extern "C" {
    pub fn glVertex4d(x: GLdouble, y: GLdouble, z: GLdouble, w: GLdouble);
}
extern "C" {
    pub fn glVertex4dv(v: *const GLdouble);
}
extern "C" {
    pub fn glVertex4f(x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat);
}
extern "C" {
    pub fn glVertex4fv(v: *const GLfloat);
}
extern "C" {
    pub fn glVertex4i(x: GLint, y: GLint, z: GLint, w: GLint);
}
extern "C" {
    pub fn glVertex4iv(v: *const GLint);
}
extern "C" {
    pub fn glVertex4s(x: GLshort, y: GLshort, z: GLshort, w: GLshort);
}
extern "C" {
    pub fn glVertex4sv(v: *const GLshort);
}
extern "C" {
    pub fn glVertexPointer(size: GLint, type_: GLenum, stride: GLsizei, pointer: *const GLvoid);
}
extern "C" {
    pub fn glViewport(x: GLint, y: GLint, width: GLsizei, height: GLsizei);
}
pub type PFNGLARRAYELEMENTEXTPROC = ::std::option::Option<unsafe extern "C" fn(i: GLint)>;
pub type PFNGLDRAWARRAYSEXTPROC =
    ::std::option::Option<unsafe extern "C" fn(mode: GLenum, first: GLint, count: GLsizei)>;
pub type PFNGLVERTEXPOINTEREXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        size: GLint,
        type_: GLenum,
        stride: GLsizei,
        count: GLsizei,
        pointer: *const GLvoid,
    ),
>;
pub type PFNGLNORMALPOINTEREXTPROC = ::std::option::Option<
    unsafe extern "C" fn(type_: GLenum, stride: GLsizei, count: GLsizei, pointer: *const GLvoid),
>;
pub type PFNGLCOLORPOINTEREXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        size: GLint,
        type_: GLenum,
        stride: GLsizei,
        count: GLsizei,
        pointer: *const GLvoid,
    ),
>;
pub type PFNGLINDEXPOINTEREXTPROC = ::std::option::Option<
    unsafe extern "C" fn(type_: GLenum, stride: GLsizei, count: GLsizei, pointer: *const GLvoid),
>;
pub type PFNGLTEXCOORDPOINTEREXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        size: GLint,
        type_: GLenum,
        stride: GLsizei,
        count: GLsizei,
        pointer: *const GLvoid,
    ),
>;
pub type PFNGLEDGEFLAGPOINTEREXTPROC = ::std::option::Option<
    unsafe extern "C" fn(stride: GLsizei, count: GLsizei, pointer: *const GLboolean),
>;
pub type PFNGLGETPOINTERVEXTPROC =
    ::std::option::Option<unsafe extern "C" fn(pname: GLenum, params: *mut *mut GLvoid)>;
pub type PFNGLARRAYELEMENTARRAYEXTPROC =
    ::std::option::Option<unsafe extern "C" fn(mode: GLenum, count: GLsizei, pi: *const GLvoid)>;
pub type PFNGLDRAWRANGEELEMENTSWINPROC = ::std::option::Option<
    unsafe extern "C" fn(
        mode: GLenum,
        start: GLuint,
        end: GLuint,
        count: GLsizei,
        type_: GLenum,
        indices: *const GLvoid,
    ),
>;
pub type PFNGLADDSWAPHINTRECTWINPROC = ::std::option::Option<
    unsafe extern "C" fn(x: GLint, y: GLint, width: GLsizei, height: GLsizei),
>;
pub type PFNGLCOLORTABLEEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        target: GLenum,
        internalFormat: GLenum,
        width: GLsizei,
        format: GLenum,
        type_: GLenum,
        data: *const GLvoid,
    ),
>;
pub type PFNGLCOLORSUBTABLEEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(
        target: GLenum,
        start: GLsizei,
        count: GLsizei,
        format: GLenum,
        type_: GLenum,
        data: *const GLvoid,
    ),
>;
pub type PFNGLGETCOLORTABLEEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(target: GLenum, format: GLenum, type_: GLenum, data: *mut GLvoid),
>;
pub type PFNGLGETCOLORTABLEPARAMETERIVEXTPROC =
    ::std::option::Option<unsafe extern "C" fn(target: GLenum, pname: GLenum, params: *mut GLint)>;
pub type PFNGLGETCOLORTABLEPARAMETERFVEXTPROC = ::std::option::Option<
    unsafe extern "C" fn(target: GLenum, pname: GLenum, params: *mut GLfloat),
>;
#[doc = " @brief Client API function pointer type."]
#[doc = ""]
#[doc = "  Generic function pointer used for returning client API function pointers"]
#[doc = "  without forcing a cast from a regular pointer."]
#[doc = ""]
#[doc = "  @sa @ref context_glext"]
#[doc = "  @sa @ref glfwGetProcAddress"]
#[doc = ""]
#[doc = "  @since Added in version 3.0."]
#[doc = ""]
#[doc = "  @ingroup context"]
pub type GLFWglproc = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " @brief Vulkan API function pointer type."]
#[doc = ""]
#[doc = "  Generic function pointer used for returning Vulkan API function pointers"]
#[doc = "  without forcing a cast from a regular pointer."]
#[doc = ""]
#[doc = "  @sa @ref vulkan_proc"]
#[doc = "  @sa @ref glfwGetInstanceProcAddress"]
#[doc = ""]
#[doc = "  @since Added in version 3.2."]
#[doc = ""]
#[doc = "  @ingroup vulkan"]
pub type GLFWvkproc = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GLFWmonitor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GLFWwindow {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GLFWcursor {
    _unused: [u8; 0],
}
#[doc = " @brief The function pointer type for error callbacks."]
#[doc = ""]
#[doc = "  This is the function pointer type for error callbacks.  An error callback"]
#[doc = "  function has the following signature:"]
#[doc = "  @code"]
#[doc = "  void callback_name(int error_code, const char* description)"]
#[doc = "  @endcode"]
#[doc = ""]
#[doc = "  @param[in] error_code An [error code](@ref errors).  Future releases may add"]
#[doc = "  more error codes."]
#[doc = "  @param[in] description A UTF-8 encoded string describing the error."]
#[doc = ""]
#[doc = "  @pointer_lifetime The error description string is valid until the callback"]
#[doc = "  function returns."]
#[doc = ""]
#[doc = "  @sa @ref error_handling"]
#[doc = "  @sa @ref glfwSetErrorCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.0."]
#[doc = ""]
#[doc = "  @ingroup init"]
pub type GLFWerrorfun = ::std::option::Option<
    unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char),
>;
#[doc = " @brief The function pointer type for window position callbacks."]
#[doc = ""]
#[doc = "  This is the function pointer type for window position callbacks.  A window"]
#[doc = "  position callback function has the following signature:"]
#[doc = "  @code"]
#[doc = "  void callback_name(GLFWwindow* window, int xpos, int ypos)"]
#[doc = "  @endcode"]
#[doc = ""]
#[doc = "  @param[in] window The window that was moved."]
#[doc = "  @param[in] xpos The new x-coordinate, in screen coordinates, of the"]
#[doc = "  upper-left corner of the content area of the window."]
#[doc = "  @param[in] ypos The new y-coordinate, in screen coordinates, of the"]
#[doc = "  upper-left corner of the content area of the window."]
#[doc = ""]
#[doc = "  @sa @ref window_pos"]
#[doc = "  @sa @ref glfwSetWindowPosCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.0."]
#[doc = ""]
#[doc = "  @ingroup window"]
pub type GLFWwindowposfun = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut GLFWwindow,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ),
>;
#[doc = " @brief The function pointer type for window size callbacks."]
#[doc = ""]
#[doc = "  This is the function pointer type for window size callbacks.  A window size"]
#[doc = "  callback function has the following signature:"]
#[doc = "  @code"]
#[doc = "  void callback_name(GLFWwindow* window, int width, int height)"]
#[doc = "  @endcode"]
#[doc = ""]
#[doc = "  @param[in] window The window that was resized."]
#[doc = "  @param[in] width The new width, in screen coordinates, of the window."]
#[doc = "  @param[in] height The new height, in screen coordinates, of the window."]
#[doc = ""]
#[doc = "  @sa @ref window_size"]
#[doc = "  @sa @ref glfwSetWindowSizeCallback"]
#[doc = ""]
#[doc = "  @since Added in version 1.0."]
#[doc = "  @glfw3 Added window handle parameter."]
#[doc = ""]
#[doc = "  @ingroup window"]
pub type GLFWwindowsizefun = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut GLFWwindow,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ),
>;
#[doc = " @brief The function pointer type for window close callbacks."]
#[doc = ""]
#[doc = "  This is the function pointer type for window close callbacks.  A window"]
#[doc = "  close callback function has the following signature:"]
#[doc = "  @code"]
#[doc = "  void function_name(GLFWwindow* window)"]
#[doc = "  @endcode"]
#[doc = ""]
#[doc = "  @param[in] window The window that the user attempted to close."]
#[doc = ""]
#[doc = "  @sa @ref window_close"]
#[doc = "  @sa @ref glfwSetWindowCloseCallback"]
#[doc = ""]
#[doc = "  @since Added in version 2.5."]
#[doc = "  @glfw3 Added window handle parameter."]
#[doc = ""]
#[doc = "  @ingroup window"]
pub type GLFWwindowclosefun = ::std::option::Option<unsafe extern "C" fn(arg1: *mut GLFWwindow)>;
#[doc = " @brief The function pointer type for window content refresh callbacks."]
#[doc = ""]
#[doc = "  This is the function pointer type for window content refresh callbacks."]
#[doc = "  A window content refresh callback function has the following signature:"]
#[doc = "  @code"]
#[doc = "  void function_name(GLFWwindow* window);"]
#[doc = "  @endcode"]
#[doc = ""]
#[doc = "  @param[in] window The window whose content needs to be refreshed."]
#[doc = ""]
#[doc = "  @sa @ref window_refresh"]
#[doc = "  @sa @ref glfwSetWindowRefreshCallback"]
#[doc = ""]
#[doc = "  @since Added in version 2.5."]
#[doc = "  @glfw3 Added window handle parameter."]
#[doc = ""]
#[doc = "  @ingroup window"]
pub type GLFWwindowrefreshfun = ::std::option::Option<unsafe extern "C" fn(arg1: *mut GLFWwindow)>;
#[doc = " @brief The function pointer type for window focus callbacks."]
#[doc = ""]
#[doc = "  This is the function pointer type for window focus callbacks.  A window"]
#[doc = "  focus callback function has the following signature:"]
#[doc = "  @code"]
#[doc = "  void function_name(GLFWwindow* window, int focused)"]
#[doc = "  @endcode"]
#[doc = ""]
#[doc = "  @param[in] window The window that gained or lost input focus."]
#[doc = "  @param[in] focused `GLFW_TRUE` if the window was given input focus, or"]
#[doc = "  `GLFW_FALSE` if it lost it."]
#[doc = ""]
#[doc = "  @sa @ref window_focus"]
#[doc = "  @sa @ref glfwSetWindowFocusCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.0."]
#[doc = ""]
#[doc = "  @ingroup window"]
pub type GLFWwindowfocusfun =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut GLFWwindow, arg2: ::std::os::raw::c_int)>;
#[doc = " @brief The function pointer type for window iconify callbacks."]
#[doc = ""]
#[doc = "  This is the function pointer type for window iconify callbacks.  A window"]
#[doc = "  iconify callback function has the following signature:"]
#[doc = "  @code"]
#[doc = "  void function_name(GLFWwindow* window, int iconified)"]
#[doc = "  @endcode"]
#[doc = ""]
#[doc = "  @param[in] window The window that was iconified or restored."]
#[doc = "  @param[in] iconified `GLFW_TRUE` if the window was iconified, or"]
#[doc = "  `GLFW_FALSE` if it was restored."]
#[doc = ""]
#[doc = "  @sa @ref window_iconify"]
#[doc = "  @sa @ref glfwSetWindowIconifyCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.0."]
#[doc = ""]
#[doc = "  @ingroup window"]
pub type GLFWwindowiconifyfun =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut GLFWwindow, arg2: ::std::os::raw::c_int)>;
#[doc = " @brief The function pointer type for window maximize callbacks."]
#[doc = ""]
#[doc = "  This is the function pointer type for window maximize callbacks.  A window"]
#[doc = "  maximize callback function has the following signature:"]
#[doc = "  @code"]
#[doc = "  void function_name(GLFWwindow* window, int maximized)"]
#[doc = "  @endcode"]
#[doc = ""]
#[doc = "  @param[in] window The window that was maximized or restored."]
#[doc = "  @param[in] iconified `GLFW_TRUE` if the window was maximized, or"]
#[doc = "  `GLFW_FALSE` if it was restored."]
#[doc = ""]
#[doc = "  @sa @ref window_maximize"]
#[doc = "  @sa glfwSetWindowMaximizeCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.3."]
#[doc = ""]
#[doc = "  @ingroup window"]
pub type GLFWwindowmaximizefun =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut GLFWwindow, arg2: ::std::os::raw::c_int)>;
#[doc = " @brief The function pointer type for framebuffer size callbacks."]
#[doc = ""]
#[doc = "  This is the function pointer type for framebuffer size callbacks."]
#[doc = "  A framebuffer size callback function has the following signature:"]
#[doc = "  @code"]
#[doc = "  void function_name(GLFWwindow* window, int width, int height)"]
#[doc = "  @endcode"]
#[doc = ""]
#[doc = "  @param[in] window The window whose framebuffer was resized."]
#[doc = "  @param[in] width The new width, in pixels, of the framebuffer."]
#[doc = "  @param[in] height The new height, in pixels, of the framebuffer."]
#[doc = ""]
#[doc = "  @sa @ref window_fbsize"]
#[doc = "  @sa @ref glfwSetFramebufferSizeCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.0."]
#[doc = ""]
#[doc = "  @ingroup window"]
pub type GLFWframebuffersizefun = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut GLFWwindow,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ),
>;
#[doc = " @brief The function pointer type for window content scale callbacks."]
#[doc = ""]
#[doc = "  This is the function pointer type for window content scale callbacks."]
#[doc = "  A window content scale callback function has the following signature:"]
#[doc = "  @code"]
#[doc = "  void function_name(GLFWwindow* window, float xscale, float yscale)"]
#[doc = "  @endcode"]
#[doc = ""]
#[doc = "  @param[in] window The window whose content scale changed."]
#[doc = "  @param[in] xscale The new x-axis content scale of the window."]
#[doc = "  @param[in] yscale The new y-axis content scale of the window."]
#[doc = ""]
#[doc = "  @sa @ref window_scale"]
#[doc = "  @sa @ref glfwSetWindowContentScaleCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.3."]
#[doc = ""]
#[doc = "  @ingroup window"]
pub type GLFWwindowcontentscalefun =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut GLFWwindow, arg2: f32, arg3: f32)>;
#[doc = " @brief The function pointer type for mouse button callbacks."]
#[doc = ""]
#[doc = "  This is the function pointer type for mouse button callback functions."]
#[doc = "  A mouse button callback function has the following signature:"]
#[doc = "  @code"]
#[doc = "  void function_name(GLFWwindow* window, int button, int action, int mods)"]
#[doc = "  @endcode"]
#[doc = ""]
#[doc = "  @param[in] window The window that received the event."]
#[doc = "  @param[in] button The [mouse button](@ref buttons) that was pressed or"]
#[doc = "  released."]
#[doc = "  @param[in] action One of `GLFW_PRESS` or `GLFW_RELEASE`.  Future releases"]
#[doc = "  may add more actions."]
#[doc = "  @param[in] mods Bit field describing which [modifier keys](@ref mods) were"]
#[doc = "  held down."]
#[doc = ""]
#[doc = "  @sa @ref input_mouse_button"]
#[doc = "  @sa @ref glfwSetMouseButtonCallback"]
#[doc = ""]
#[doc = "  @since Added in version 1.0."]
#[doc = "  @glfw3 Added window handle and modifier mask parameters."]
#[doc = ""]
#[doc = "  @ingroup input"]
pub type GLFWmousebuttonfun = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut GLFWwindow,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ),
>;
#[doc = " @brief The function pointer type for cursor position callbacks."]
#[doc = ""]
#[doc = "  This is the function pointer type for cursor position callbacks.  A cursor"]
#[doc = "  position callback function has the following signature:"]
#[doc = "  @code"]
#[doc = "  void function_name(GLFWwindow* window, double xpos, double ypos);"]
#[doc = "  @endcode"]
#[doc = ""]
#[doc = "  @param[in] window The window that received the event."]
#[doc = "  @param[in] xpos The new cursor x-coordinate, relative to the left edge of"]
#[doc = "  the content area."]
#[doc = "  @param[in] ypos The new cursor y-coordinate, relative to the top edge of the"]
#[doc = "  content area."]
#[doc = ""]
#[doc = "  @sa @ref cursor_pos"]
#[doc = "  @sa @ref glfwSetCursorPosCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.0.  Replaces `GLFWmouseposfun`."]
#[doc = ""]
#[doc = "  @ingroup input"]
pub type GLFWcursorposfun =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut GLFWwindow, arg2: f64, arg3: f64)>;
#[doc = " @brief The function pointer type for cursor enter/leave callbacks."]
#[doc = ""]
#[doc = "  This is the function pointer type for cursor enter/leave callbacks."]
#[doc = "  A cursor enter/leave callback function has the following signature:"]
#[doc = "  @code"]
#[doc = "  void function_name(GLFWwindow* window, int entered)"]
#[doc = "  @endcode"]
#[doc = ""]
#[doc = "  @param[in] window The window that received the event."]
#[doc = "  @param[in] entered `GLFW_TRUE` if the cursor entered the window's content"]
#[doc = "  area, or `GLFW_FALSE` if it left it."]
#[doc = ""]
#[doc = "  @sa @ref cursor_enter"]
#[doc = "  @sa @ref glfwSetCursorEnterCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.0."]
#[doc = ""]
#[doc = "  @ingroup input"]
pub type GLFWcursorenterfun =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut GLFWwindow, arg2: ::std::os::raw::c_int)>;
#[doc = " @brief The function pointer type for scroll callbacks."]
#[doc = ""]
#[doc = "  This is the function pointer type for scroll callbacks.  A scroll callback"]
#[doc = "  function has the following signature:"]
#[doc = "  @code"]
#[doc = "  void function_name(GLFWwindow* window, double xoffset, double yoffset)"]
#[doc = "  @endcode"]
#[doc = ""]
#[doc = "  @param[in] window The window that received the event."]
#[doc = "  @param[in] xoffset The scroll offset along the x-axis."]
#[doc = "  @param[in] yoffset The scroll offset along the y-axis."]
#[doc = ""]
#[doc = "  @sa @ref scrolling"]
#[doc = "  @sa @ref glfwSetScrollCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.0.  Replaces `GLFWmousewheelfun`."]
#[doc = ""]
#[doc = "  @ingroup input"]
pub type GLFWscrollfun =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut GLFWwindow, arg2: f64, arg3: f64)>;
#[doc = " @brief The function pointer type for keyboard key callbacks."]
#[doc = ""]
#[doc = "  This is the function pointer type for keyboard key callbacks.  A keyboard"]
#[doc = "  key callback function has the following signature:"]
#[doc = "  @code"]
#[doc = "  void function_name(GLFWwindow* window, int key, int scancode, int action, int mods)"]
#[doc = "  @endcode"]
#[doc = ""]
#[doc = "  @param[in] window The window that received the event."]
#[doc = "  @param[in] key The [keyboard key](@ref keys) that was pressed or released."]
#[doc = "  @param[in] scancode The system-specific scancode of the key."]
#[doc = "  @param[in] action `GLFW_PRESS`, `GLFW_RELEASE` or `GLFW_REPEAT`.  Future"]
#[doc = "  releases may add more actions."]
#[doc = "  @param[in] mods Bit field describing which [modifier keys](@ref mods) were"]
#[doc = "  held down."]
#[doc = ""]
#[doc = "  @sa @ref input_key"]
#[doc = "  @sa @ref glfwSetKeyCallback"]
#[doc = ""]
#[doc = "  @since Added in version 1.0."]
#[doc = "  @glfw3 Added window handle, scancode and modifier mask parameters."]
#[doc = ""]
#[doc = "  @ingroup input"]
pub type GLFWkeyfun = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut GLFWwindow,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
    ),
>;
#[doc = " @brief The function pointer type for Unicode character callbacks."]
#[doc = ""]
#[doc = "  This is the function pointer type for Unicode character callbacks."]
#[doc = "  A Unicode character callback function has the following signature:"]
#[doc = "  @code"]
#[doc = "  void function_name(GLFWwindow* window, unsigned int codepoint)"]
#[doc = "  @endcode"]
#[doc = ""]
#[doc = "  @param[in] window The window that received the event."]
#[doc = "  @param[in] codepoint The Unicode code point of the character."]
#[doc = ""]
#[doc = "  @sa @ref input_char"]
#[doc = "  @sa @ref glfwSetCharCallback"]
#[doc = ""]
#[doc = "  @since Added in version 2.4."]
#[doc = "  @glfw3 Added window handle parameter."]
#[doc = ""]
#[doc = "  @ingroup input"]
pub type GLFWcharfun = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut GLFWwindow, arg2: ::std::os::raw::c_uint),
>;
#[doc = " @brief The function pointer type for Unicode character with modifiers"]
#[doc = "  callbacks."]
#[doc = ""]
#[doc = "  This is the function pointer type for Unicode character with modifiers"]
#[doc = "  callbacks.  It is called for each input character, regardless of what"]
#[doc = "  modifier keys are held down.  A Unicode character with modifiers callback"]
#[doc = "  function has the following signature:"]
#[doc = "  @code"]
#[doc = "  void function_name(GLFWwindow* window, unsigned int codepoint, int mods)"]
#[doc = "  @endcode"]
#[doc = ""]
#[doc = "  @param[in] window The window that received the event."]
#[doc = "  @param[in] codepoint The Unicode code point of the character."]
#[doc = "  @param[in] mods Bit field describing which [modifier keys](@ref mods) were"]
#[doc = "  held down."]
#[doc = ""]
#[doc = "  @sa @ref input_char"]
#[doc = "  @sa @ref glfwSetCharModsCallback"]
#[doc = ""]
#[doc = "  @deprecated Scheduled for removal in version 4.0."]
#[doc = ""]
#[doc = "  @since Added in version 3.1."]
#[doc = ""]
#[doc = "  @ingroup input"]
pub type GLFWcharmodsfun = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut GLFWwindow,
        arg2: ::std::os::raw::c_uint,
        arg3: ::std::os::raw::c_int,
    ),
>;
#[doc = " @brief The function pointer type for path drop callbacks."]
#[doc = ""]
#[doc = "  This is the function pointer type for path drop callbacks.  A path drop"]
#[doc = "  callback function has the following signature:"]
#[doc = "  @code"]
#[doc = "  void function_name(GLFWwindow* window, int path_count, const char* paths[])"]
#[doc = "  @endcode"]
#[doc = ""]
#[doc = "  @param[in] window The window that received the event."]
#[doc = "  @param[in] path_count The number of dropped paths."]
#[doc = "  @param[in] paths The UTF-8 encoded file and/or directory path names."]
#[doc = ""]
#[doc = "  @pointer_lifetime The path array and its strings are valid until the"]
#[doc = "  callback function returns."]
#[doc = ""]
#[doc = "  @sa @ref path_drop"]
#[doc = "  @sa @ref glfwSetDropCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.1."]
#[doc = ""]
#[doc = "  @ingroup input"]
pub type GLFWdropfun = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut GLFWwindow,
        arg2: ::std::os::raw::c_int,
        arg3: *mut *const ::std::os::raw::c_char,
    ),
>;
#[doc = " @brief The function pointer type for monitor configuration callbacks."]
#[doc = ""]
#[doc = "  This is the function pointer type for monitor configuration callbacks."]
#[doc = "  A monitor callback function has the following signature:"]
#[doc = "  @code"]
#[doc = "  void function_name(GLFWmonitor* monitor, int event)"]
#[doc = "  @endcode"]
#[doc = ""]
#[doc = "  @param[in] monitor The monitor that was connected or disconnected."]
#[doc = "  @param[in] event One of `GLFW_CONNECTED` or `GLFW_DISCONNECTED`.  Future"]
#[doc = "  releases may add more events."]
#[doc = ""]
#[doc = "  @sa @ref monitor_event"]
#[doc = "  @sa @ref glfwSetMonitorCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.0."]
#[doc = ""]
#[doc = "  @ingroup monitor"]
pub type GLFWmonitorfun = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut GLFWmonitor, arg2: ::std::os::raw::c_int),
>;
#[doc = " @brief The function pointer type for joystick configuration callbacks."]
#[doc = ""]
#[doc = "  This is the function pointer type for joystick configuration callbacks."]
#[doc = "  A joystick configuration callback function has the following signature:"]
#[doc = "  @code"]
#[doc = "  void function_name(int jid, int event)"]
#[doc = "  @endcode"]
#[doc = ""]
#[doc = "  @param[in] jid The joystick that was connected or disconnected."]
#[doc = "  @param[in] event One of `GLFW_CONNECTED` or `GLFW_DISCONNECTED`.  Future"]
#[doc = "  releases may add more events."]
#[doc = ""]
#[doc = "  @sa @ref joystick_event"]
#[doc = "  @sa @ref glfwSetJoystickCallback"]
#[doc = ""]
#[doc = "  @since Added in version 3.2."]
#[doc = ""]
#[doc = "  @ingroup input"]
pub type GLFWjoystickfun = ::std::option::Option<
    unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int),
>;
#[doc = " @brief Video mode type."]
#[doc = ""]
#[doc = "  This describes a single video mode."]
#[doc = ""]
#[doc = "  @sa @ref monitor_modes"]
#[doc = "  @sa @ref glfwGetVideoMode"]
#[doc = "  @sa @ref glfwGetVideoModes"]
#[doc = ""]
#[doc = "  @since Added in version 1.0."]
#[doc = "  @glfw3 Added refresh rate member."]
#[doc = ""]
#[doc = "  @ingroup monitor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GLFWvidmode {
    #[doc = " The width, in screen coordinates, of the video mode."]
    pub width: ::std::os::raw::c_int,
    #[doc = " The height, in screen coordinates, of the video mode."]
    pub height: ::std::os::raw::c_int,
    #[doc = " The bit depth of the red channel of the video mode."]
    pub redBits: ::std::os::raw::c_int,
    #[doc = " The bit depth of the green channel of the video mode."]
    pub greenBits: ::std::os::raw::c_int,
    #[doc = " The bit depth of the blue channel of the video mode."]
    pub blueBits: ::std::os::raw::c_int,
    #[doc = " The refresh rate, in Hz, of the video mode."]
    pub refreshRate: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_GLFWvidmode() {
    assert_eq!(
        ::std::mem::size_of::<GLFWvidmode>(),
        24usize,
        concat!("Size of: ", stringify!(GLFWvidmode))
    );
    assert_eq!(
        ::std::mem::align_of::<GLFWvidmode>(),
        4usize,
        concat!("Alignment of ", stringify!(GLFWvidmode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GLFWvidmode>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GLFWvidmode),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GLFWvidmode>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GLFWvidmode),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GLFWvidmode>())).redBits as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GLFWvidmode),
            "::",
            stringify!(redBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GLFWvidmode>())).greenBits as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GLFWvidmode),
            "::",
            stringify!(greenBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GLFWvidmode>())).blueBits as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GLFWvidmode),
            "::",
            stringify!(blueBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GLFWvidmode>())).refreshRate as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GLFWvidmode),
            "::",
            stringify!(refreshRate)
        )
    );
}
#[doc = " @brief Gamma ramp."]
#[doc = ""]
#[doc = "  This describes the gamma ramp for a monitor."]
#[doc = ""]
#[doc = "  @sa @ref monitor_gamma"]
#[doc = "  @sa @ref glfwGetGammaRamp"]
#[doc = "  @sa @ref glfwSetGammaRamp"]
#[doc = ""]
#[doc = "  @since Added in version 3.0."]
#[doc = ""]
#[doc = "  @ingroup monitor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GLFWgammaramp {
    #[doc = " An array of value describing the response of the red channel."]
    pub red: *mut ::std::os::raw::c_ushort,
    #[doc = " An array of value describing the response of the green channel."]
    pub green: *mut ::std::os::raw::c_ushort,
    #[doc = " An array of value describing the response of the blue channel."]
    pub blue: *mut ::std::os::raw::c_ushort,
    #[doc = " The number of elements in each array."]
    pub size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_GLFWgammaramp() {
    assert_eq!(
        ::std::mem::size_of::<GLFWgammaramp>(),
        32usize,
        concat!("Size of: ", stringify!(GLFWgammaramp))
    );
    assert_eq!(
        ::std::mem::align_of::<GLFWgammaramp>(),
        8usize,
        concat!("Alignment of ", stringify!(GLFWgammaramp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GLFWgammaramp>())).red as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GLFWgammaramp),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GLFWgammaramp>())).green as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GLFWgammaramp),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GLFWgammaramp>())).blue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GLFWgammaramp),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GLFWgammaramp>())).size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GLFWgammaramp),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " @brief Image data."]
#[doc = ""]
#[doc = "  This describes a single 2D image.  See the documentation for each related"]
#[doc = "  function what the expected pixel format is."]
#[doc = ""]
#[doc = "  @sa @ref cursor_custom"]
#[doc = "  @sa @ref window_icon"]
#[doc = ""]
#[doc = "  @since Added in version 2.1."]
#[doc = "  @glfw3 Removed format and bytes-per-pixel members."]
#[doc = ""]
#[doc = "  @ingroup window"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GLFWimage {
    #[doc = " The width, in pixels, of this image."]
    pub width: ::std::os::raw::c_int,
    #[doc = " The height, in pixels, of this image."]
    pub height: ::std::os::raw::c_int,
    #[doc = " The pixel data of this image, arranged left-to-right, top-to-bottom."]
    pub pixels: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_GLFWimage() {
    assert_eq!(
        ::std::mem::size_of::<GLFWimage>(),
        16usize,
        concat!("Size of: ", stringify!(GLFWimage))
    );
    assert_eq!(
        ::std::mem::align_of::<GLFWimage>(),
        8usize,
        concat!("Alignment of ", stringify!(GLFWimage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GLFWimage>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GLFWimage),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GLFWimage>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GLFWimage),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GLFWimage>())).pixels as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GLFWimage),
            "::",
            stringify!(pixels)
        )
    );
}
#[doc = " @brief Gamepad input state"]
#[doc = ""]
#[doc = "  This describes the input state of a gamepad."]
#[doc = ""]
#[doc = "  @sa @ref gamepad"]
#[doc = "  @sa @ref glfwGetGamepadState"]
#[doc = ""]
#[doc = "  @since Added in version 3.3."]
#[doc = ""]
#[doc = "  @ingroup input"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GLFWgamepadstate {
    #[doc = " The states of each [gamepad button](@ref gamepad_buttons), `GLFW_PRESS`"]
    #[doc = "  or `GLFW_RELEASE`."]
    pub buttons: [::std::os::raw::c_uchar; 15usize],
    #[doc = " The states of each [gamepad axis](@ref gamepad_axes), in the range -1.0"]
    #[doc = "  to 1.0 inclusive."]
    pub axes: [f32; 6usize],
}
#[test]
fn bindgen_test_layout_GLFWgamepadstate() {
    assert_eq!(
        ::std::mem::size_of::<GLFWgamepadstate>(),
        40usize,
        concat!("Size of: ", stringify!(GLFWgamepadstate))
    );
    assert_eq!(
        ::std::mem::align_of::<GLFWgamepadstate>(),
        4usize,
        concat!("Alignment of ", stringify!(GLFWgamepadstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GLFWgamepadstate>())).buttons as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GLFWgamepadstate),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GLFWgamepadstate>())).axes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GLFWgamepadstate),
            "::",
            stringify!(axes)
        )
    );
}
extern "C" {
    #[doc = " @brief Initializes the GLFW library."]
    #[doc = ""]
    #[doc = "  This function initializes the GLFW library.  Before most GLFW functions can"]
    #[doc = "  be used, GLFW must be initialized, and before an application terminates GLFW"]
    #[doc = "  should be terminated in order to free any resources allocated during or"]
    #[doc = "  after initialization."]
    #[doc = ""]
    #[doc = "  If this function fails, it calls @ref glfwTerminate before returning.  If it"]
    #[doc = "  succeeds, you should call @ref glfwTerminate before the application exits."]
    #[doc = ""]
    #[doc = "  Additional calls to this function after successful initialization but before"]
    #[doc = "  termination will return `GLFW_TRUE` immediately."]
    #[doc = ""]
    #[doc = "  @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark @macos This function will change the current directory of the"]
    #[doc = "  application to the `Contents/Resources` subdirectory of the application's"]
    #[doc = "  bundle, if present.  This can be disabled with the @ref"]
    #[doc = "  GLFW_COCOA_CHDIR_RESOURCES init hint."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref intro_init"]
    #[doc = "  @sa @ref glfwTerminate"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = ""]
    #[doc = "  @ingroup init"]
    pub fn glfwInit() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Terminates the GLFW library."]
    #[doc = ""]
    #[doc = "  This function destroys all remaining windows and cursors, restores any"]
    #[doc = "  modified gamma ramps and frees any other allocated resources.  Once this"]
    #[doc = "  function is called, you must again call @ref glfwInit successfully before"]
    #[doc = "  you will be able to use most GLFW functions."]
    #[doc = ""]
    #[doc = "  If GLFW has been successfully initialized, this function should be called"]
    #[doc = "  before the application exits.  If initialization fails, there is no need to"]
    #[doc = "  call this function, as it is called by @ref glfwInit before it returns"]
    #[doc = "  failure."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark This function may be called before @ref glfwInit."]
    #[doc = ""]
    #[doc = "  @warning The contexts of any remaining windows must not be current on any"]
    #[doc = "  other thread when this function is called."]
    #[doc = ""]
    #[doc = "  @reentrancy This function must not be called from a callback."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref intro_init"]
    #[doc = "  @sa @ref glfwInit"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = ""]
    #[doc = "  @ingroup init"]
    pub fn glfwTerminate();
}
extern "C" {
    #[doc = " @brief Sets the specified init hint to the desired value."]
    #[doc = ""]
    #[doc = "  This function sets hints for the next initialization of GLFW."]
    #[doc = ""]
    #[doc = "  The values you set hints to are never reset by GLFW, but they only take"]
    #[doc = "  effect during initialization.  Once GLFW has been initialized, any values"]
    #[doc = "  you set will be ignored until the library is terminated and initialized"]
    #[doc = "  again."]
    #[doc = ""]
    #[doc = "  Some hints are platform specific.  These may be set on any platform but they"]
    #[doc = "  will only affect their specific platform.  Other platforms will ignore them."]
    #[doc = "  Setting these hints requires no platform specific headers or functions."]
    #[doc = ""]
    #[doc = "  @param[in] hint The [init hint](@ref init_hints) to set."]
    #[doc = "  @param[in] value The new value of the init hint."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_INVALID_ENUM and @ref"]
    #[doc = "  GLFW_INVALID_VALUE."]
    #[doc = ""]
    #[doc = "  @remarks This function may be called before @ref glfwInit."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa init_hints"]
    #[doc = "  @sa glfwInit"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup init"]
    pub fn glfwInitHint(hint: ::std::os::raw::c_int, value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Retrieves the version of the GLFW library."]
    #[doc = ""]
    #[doc = "  This function retrieves the major, minor and revision numbers of the GLFW"]
    #[doc = "  library.  It is intended for when you are using GLFW as a shared library and"]
    #[doc = "  want to ensure that you are using the minimum required version."]
    #[doc = ""]
    #[doc = "  Any or all of the version arguments may be `NULL`."]
    #[doc = ""]
    #[doc = "  @param[out] major Where to store the major version number, or `NULL`."]
    #[doc = "  @param[out] minor Where to store the minor version number, or `NULL`."]
    #[doc = "  @param[out] rev Where to store the revision number, or `NULL`."]
    #[doc = ""]
    #[doc = "  @errors None."]
    #[doc = ""]
    #[doc = "  @remark This function may be called before @ref glfwInit."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref intro_version"]
    #[doc = "  @sa @ref glfwGetVersionString"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = ""]
    #[doc = "  @ingroup init"]
    pub fn glfwGetVersion(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        rev: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Returns a string describing the compile-time configuration."]
    #[doc = ""]
    #[doc = "  This function returns the compile-time generated"]
    #[doc = "  [version string](@ref intro_version_string) of the GLFW library binary.  It"]
    #[doc = "  describes the version, platform, compiler and any platform-specific"]
    #[doc = "  compile-time options.  It should not be confused with the OpenGL or OpenGL"]
    #[doc = "  ES version string, queried with `glGetString`."]
    #[doc = ""]
    #[doc = "  __Do not use the version string__ to parse the GLFW library version.  The"]
    #[doc = "  @ref glfwGetVersion function provides the version of the running library"]
    #[doc = "  binary in numerical format."]
    #[doc = ""]
    #[doc = "  @return The ASCII encoded GLFW version string."]
    #[doc = ""]
    #[doc = "  @errors None."]
    #[doc = ""]
    #[doc = "  @remark This function may be called before @ref glfwInit."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned string is static and compile-time generated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref intro_version"]
    #[doc = "  @sa @ref glfwGetVersion"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup init"]
    pub fn glfwGetVersionString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns and clears the last error for the calling thread."]
    #[doc = ""]
    #[doc = "  This function returns and clears the [error code](@ref errors) of the last"]
    #[doc = "  error that occurred on the calling thread, and optionally a UTF-8 encoded"]
    #[doc = "  human-readable description of it.  If no error has occurred since the last"]
    #[doc = "  call, it returns @ref GLFW_NO_ERROR (zero) and the description pointer is"]
    #[doc = "  set to `NULL`."]
    #[doc = ""]
    #[doc = "  @param[in] description Where to store the error description pointer, or `NULL`."]
    #[doc = "  @return The last error code for the calling thread, or @ref GLFW_NO_ERROR"]
    #[doc = "  (zero)."]
    #[doc = ""]
    #[doc = "  @errors None."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned string is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is guaranteed to be valid only until the"]
    #[doc = "  next error occurs or the library is terminated."]
    #[doc = ""]
    #[doc = "  @remark This function may be called before @ref glfwInit."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref error_handling"]
    #[doc = "  @sa @ref glfwSetErrorCallback"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup init"]
    pub fn glfwGetError(description: *mut *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Sets the error callback."]
    #[doc = ""]
    #[doc = "  This function sets the error callback, which is called with an error code"]
    #[doc = "  and a human-readable description each time a GLFW error occurs."]
    #[doc = ""]
    #[doc = "  The error code is set before the callback is called.  Calling @ref"]
    #[doc = "  glfwGetError from the error callback will return the same value as the error"]
    #[doc = "  code argument."]
    #[doc = ""]
    #[doc = "  The error callback is called on the thread where the error occurred.  If you"]
    #[doc = "  are using GLFW from multiple threads, your error callback needs to be"]
    #[doc = "  written accordingly."]
    #[doc = ""]
    #[doc = "  Because the description string may have been generated specifically for that"]
    #[doc = "  error, it is not guaranteed to be valid after the callback has returned.  If"]
    #[doc = "  you wish to use it after the callback returns, you need to make a copy."]
    #[doc = ""]
    #[doc = "  Once set, the error callback remains set even after the library has been"]
    #[doc = "  terminated."]
    #[doc = ""]
    #[doc = "  @param[in] callback The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set."]
    #[doc = ""]
    #[doc = "  @callback_signature"]
    #[doc = "  @code"]
    #[doc = "  void callback_name(int error_code, const char* description)"]
    #[doc = "  @endcode"]
    #[doc = "  For more information about the callback parameters, see the"]
    #[doc = "  [callback pointer type](@ref GLFWerrorfun)."]
    #[doc = ""]
    #[doc = "  @errors None."]
    #[doc = ""]
    #[doc = "  @remark This function may be called before @ref glfwInit."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref error_handling"]
    #[doc = "  @sa @ref glfwGetError"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup init"]
    pub fn glfwSetErrorCallback(callback: GLFWerrorfun) -> GLFWerrorfun;
}
extern "C" {
    #[doc = " @brief Returns the currently connected monitors."]
    #[doc = ""]
    #[doc = "  This function returns an array of handles for all currently connected"]
    #[doc = "  monitors.  The primary monitor is always first in the returned array.  If no"]
    #[doc = "  monitors were found, this function returns `NULL`."]
    #[doc = ""]
    #[doc = "  @param[out] count Where to store the number of monitors in the returned"]
    #[doc = "  array.  This is set to zero if an error occurred."]
    #[doc = "  @return An array of monitor handles, or `NULL` if no monitors were found or"]
    #[doc = "  if an [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned array is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is guaranteed to be valid only until the"]
    #[doc = "  monitor configuration changes or the library is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_monitors"]
    #[doc = "  @sa @ref monitor_event"]
    #[doc = "  @sa @ref glfwGetPrimaryMonitor"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwGetMonitors(count: *mut ::std::os::raw::c_int) -> *mut *mut GLFWmonitor;
}
extern "C" {
    #[doc = " @brief Returns the primary monitor."]
    #[doc = ""]
    #[doc = "  This function returns the primary monitor.  This is usually the monitor"]
    #[doc = "  where elements like the task bar or global menu bar are located."]
    #[doc = ""]
    #[doc = "  @return The primary monitor, or `NULL` if no monitors were found or if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @remark The primary monitor is always first in the array returned by @ref"]
    #[doc = "  glfwGetMonitors."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_monitors"]
    #[doc = "  @sa @ref glfwGetMonitors"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwGetPrimaryMonitor() -> *mut GLFWmonitor;
}
extern "C" {
    #[doc = " @brief Returns the position of the monitor's viewport on the virtual screen."]
    #[doc = ""]
    #[doc = "  This function returns the position, in screen coordinates, of the upper-left"]
    #[doc = "  corner of the specified monitor."]
    #[doc = ""]
    #[doc = "  Any or all of the position arguments may be `NULL`.  If an error occurs, all"]
    #[doc = "  non-`NULL` position arguments will be set to zero."]
    #[doc = ""]
    #[doc = "  @param[in] monitor The monitor to query."]
    #[doc = "  @param[out] xpos Where to store the monitor x-coordinate, or `NULL`."]
    #[doc = "  @param[out] ypos Where to store the monitor y-coordinate, or `NULL`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_properties"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwGetMonitorPos(
        monitor: *mut GLFWmonitor,
        xpos: *mut ::std::os::raw::c_int,
        ypos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Retrieves the work area of the monitor."]
    #[doc = ""]
    #[doc = "  This function returns the position, in screen coordinates, of the upper-left"]
    #[doc = "  corner of the work area of the specified monitor along with the work area"]
    #[doc = "  size in screen coordinates. The work area is defined as the area of the"]
    #[doc = "  monitor not occluded by the operating system task bar where present. If no"]
    #[doc = "  task bar exists then the work area is the monitor resolution in screen"]
    #[doc = "  coordinates."]
    #[doc = ""]
    #[doc = "  Any or all of the position and size arguments may be `NULL`.  If an error"]
    #[doc = "  occurs, all non-`NULL` position and size arguments will be set to zero."]
    #[doc = ""]
    #[doc = "  @param[in] monitor The monitor to query."]
    #[doc = "  @param[out] xpos Where to store the monitor x-coordinate, or `NULL`."]
    #[doc = "  @param[out] ypos Where to store the monitor y-coordinate, or `NULL`."]
    #[doc = "  @param[out] width Where to store the monitor width, or `NULL`."]
    #[doc = "  @param[out] height Where to store the monitor height, or `NULL`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_workarea"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwGetMonitorWorkarea(
        monitor: *mut GLFWmonitor,
        xpos: *mut ::std::os::raw::c_int,
        ypos: *mut ::std::os::raw::c_int,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Returns the physical size of the monitor."]
    #[doc = ""]
    #[doc = "  This function returns the size, in millimetres, of the display area of the"]
    #[doc = "  specified monitor."]
    #[doc = ""]
    #[doc = "  Some systems do not provide accurate monitor size information, either"]
    #[doc = "  because the monitor"]
    #[doc = "  [EDID](https://en.wikipedia.org/wiki/Extended_display_identification_data)"]
    #[doc = "  data is incorrect or because the driver does not report it accurately."]
    #[doc = ""]
    #[doc = "  Any or all of the size arguments may be `NULL`.  If an error occurs, all"]
    #[doc = "  non-`NULL` size arguments will be set to zero."]
    #[doc = ""]
    #[doc = "  @param[in] monitor The monitor to query."]
    #[doc = "  @param[out] widthMM Where to store the width, in millimetres, of the"]
    #[doc = "  monitor's display area, or `NULL`."]
    #[doc = "  @param[out] heightMM Where to store the height, in millimetres, of the"]
    #[doc = "  monitor's display area, or `NULL`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @remark @win32 calculates the returned physical size from the"]
    #[doc = "  current resolution and system DPI instead of querying the monitor EDID data."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_properties"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwGetMonitorPhysicalSize(
        monitor: *mut GLFWmonitor,
        widthMM: *mut ::std::os::raw::c_int,
        heightMM: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Retrieves the content scale for the specified monitor."]
    #[doc = ""]
    #[doc = "  This function retrieves the content scale for the specified monitor.  The"]
    #[doc = "  content scale is the ratio between the current DPI and the platform's"]
    #[doc = "  default DPI.  This is especially important for text and any UI elements.  If"]
    #[doc = "  the pixel dimensions of your UI scaled by this look appropriate on your"]
    #[doc = "  machine then it should appear at a reasonable size on other machines"]
    #[doc = "  regardless of their DPI and scaling settings.  This relies on the system DPI"]
    #[doc = "  and scaling settings being somewhat correct."]
    #[doc = ""]
    #[doc = "  The content scale may depend on both the monitor resolution and pixel"]
    #[doc = "  density and on user settings.  It may be very different from the raw DPI"]
    #[doc = "  calculated from the physical size and current resolution."]
    #[doc = ""]
    #[doc = "  @param[in] monitor The monitor to query."]
    #[doc = "  @param[out] xscale Where to store the x-axis content scale, or `NULL`."]
    #[doc = "  @param[out] yscale Where to store the y-axis content scale, or `NULL`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_scale"]
    #[doc = "  @sa @ref glfwGetWindowContentScale"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwGetMonitorContentScale(
        monitor: *mut GLFWmonitor,
        xscale: *mut f32,
        yscale: *mut f32,
    );
}
extern "C" {
    #[doc = " @brief Returns the name of the specified monitor."]
    #[doc = ""]
    #[doc = "  This function returns a human-readable name, encoded as UTF-8, of the"]
    #[doc = "  specified monitor.  The name typically reflects the make and model of the"]
    #[doc = "  monitor and is not guaranteed to be unique among the connected monitors."]
    #[doc = ""]
    #[doc = "  @param[in] monitor The monitor to query."]
    #[doc = "  @return The UTF-8 encoded name of the monitor, or `NULL` if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned string is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is valid until the specified monitor is"]
    #[doc = "  disconnected or the library is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_properties"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwGetMonitorName(monitor: *mut GLFWmonitor) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Sets the user pointer of the specified monitor."]
    #[doc = ""]
    #[doc = "  This function sets the user-defined pointer of the specified monitor.  The"]
    #[doc = "  current value is retained until the monitor is disconnected.  The initial"]
    #[doc = "  value is `NULL`."]
    #[doc = ""]
    #[doc = "  This function may be called from the monitor callback, even for a monitor"]
    #[doc = "  that is being disconnected."]
    #[doc = ""]
    #[doc = "  @param[in] monitor The monitor whose pointer to set."]
    #[doc = "  @param[in] pointer The new value."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread.  Access is not"]
    #[doc = "  synchronized."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_userptr"]
    #[doc = "  @sa @ref glfwGetMonitorUserPointer"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwSetMonitorUserPointer(
        monitor: *mut GLFWmonitor,
        pointer: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Returns the user pointer of the specified monitor."]
    #[doc = ""]
    #[doc = "  This function returns the current value of the user-defined pointer of the"]
    #[doc = "  specified monitor.  The initial value is `NULL`."]
    #[doc = ""]
    #[doc = "  This function may be called from the monitor callback, even for a monitor"]
    #[doc = "  that is being disconnected."]
    #[doc = ""]
    #[doc = "  @param[in] monitor The monitor whose pointer to return."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread.  Access is not"]
    #[doc = "  synchronized."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_userptr"]
    #[doc = "  @sa @ref glfwSetMonitorUserPointer"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwGetMonitorUserPointer(monitor: *mut GLFWmonitor) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Sets the monitor configuration callback."]
    #[doc = ""]
    #[doc = "  This function sets the monitor configuration callback, or removes the"]
    #[doc = "  currently set callback.  This is called when a monitor is connected to or"]
    #[doc = "  disconnected from the system."]
    #[doc = ""]
    #[doc = "  @param[in] callback The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @callback_signature"]
    #[doc = "  @code"]
    #[doc = "  void function_name(GLFWmonitor* monitor, int event)"]
    #[doc = "  @endcode"]
    #[doc = "  For more information about the callback parameters, see the"]
    #[doc = "  [function pointer type](@ref GLFWmonitorfun)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_event"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwSetMonitorCallback(callback: GLFWmonitorfun) -> GLFWmonitorfun;
}
extern "C" {
    #[doc = " @brief Returns the available video modes for the specified monitor."]
    #[doc = ""]
    #[doc = "  This function returns an array of all video modes supported by the specified"]
    #[doc = "  monitor.  The returned array is sorted in ascending order, first by color"]
    #[doc = "  bit depth (the sum of all channel depths) and then by resolution area (the"]
    #[doc = "  product of width and height)."]
    #[doc = ""]
    #[doc = "  @param[in] monitor The monitor to query."]
    #[doc = "  @param[out] count Where to store the number of video modes in the returned"]
    #[doc = "  array.  This is set to zero if an error occurred."]
    #[doc = "  @return An array of video modes, or `NULL` if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned array is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is valid until the specified monitor is"]
    #[doc = "  disconnected, this function is called again for that monitor or the library"]
    #[doc = "  is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_modes"]
    #[doc = "  @sa @ref glfwGetVideoMode"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = "  @glfw3 Changed to return an array of modes for a specific monitor."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwGetVideoModes(
        monitor: *mut GLFWmonitor,
        count: *mut ::std::os::raw::c_int,
    ) -> *const GLFWvidmode;
}
extern "C" {
    #[doc = " @brief Returns the current mode of the specified monitor."]
    #[doc = ""]
    #[doc = "  This function returns the current video mode of the specified monitor.  If"]
    #[doc = "  you have created a full screen window for that monitor, the return value"]
    #[doc = "  will depend on whether that window is iconified."]
    #[doc = ""]
    #[doc = "  @param[in] monitor The monitor to query."]
    #[doc = "  @return The current mode of the monitor, or `NULL` if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned array is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is valid until the specified monitor is"]
    #[doc = "  disconnected or the library is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_modes"]
    #[doc = "  @sa @ref glfwGetVideoModes"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwGetDesktopMode`."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwGetVideoMode(monitor: *mut GLFWmonitor) -> *const GLFWvidmode;
}
extern "C" {
    #[doc = " @brief Generates a gamma ramp and sets it for the specified monitor."]
    #[doc = ""]
    #[doc = "  This function generates an appropriately sized gamma ramp from the specified"]
    #[doc = "  exponent and then calls @ref glfwSetGammaRamp with it.  The value must be"]
    #[doc = "  a finite number greater than zero."]
    #[doc = ""]
    #[doc = "  The software controlled gamma ramp is applied _in addition_ to the hardware"]
    #[doc = "  gamma correction, which today is usually an approximation of sRGB gamma."]
    #[doc = "  This means that setting a perfectly linear ramp, or gamma 1.0, will produce"]
    #[doc = "  the default (usually sRGB-like) behavior."]
    #[doc = ""]
    #[doc = "  For gamma correct rendering with OpenGL or OpenGL ES, see the @ref"]
    #[doc = "  GLFW_SRGB_CAPABLE hint."]
    #[doc = ""]
    #[doc = "  @param[in] monitor The monitor whose gamma ramp to set."]
    #[doc = "  @param[in] gamma The desired exponent."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark @wayland Gamma handling is a privileged protocol, this function"]
    #[doc = "  will thus never be implemented and emits @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_gamma"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwSetGamma(monitor: *mut GLFWmonitor, gamma: f32);
}
extern "C" {
    #[doc = " @brief Returns the current gamma ramp for the specified monitor."]
    #[doc = ""]
    #[doc = "  This function returns the current gamma ramp of the specified monitor."]
    #[doc = ""]
    #[doc = "  @param[in] monitor The monitor to query."]
    #[doc = "  @return The current gamma ramp, or `NULL` if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark @wayland Gamma handling is a privileged protocol, this function"]
    #[doc = "  will thus never be implemented and emits @ref GLFW_PLATFORM_ERROR while"]
    #[doc = "  returning `NULL`."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned structure and its arrays are allocated and"]
    #[doc = "  freed by GLFW.  You should not free them yourself.  They are valid until the"]
    #[doc = "  specified monitor is disconnected, this function is called again for that"]
    #[doc = "  monitor or the library is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_gamma"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwGetGammaRamp(monitor: *mut GLFWmonitor) -> *const GLFWgammaramp;
}
extern "C" {
    #[doc = " @brief Sets the current gamma ramp for the specified monitor."]
    #[doc = ""]
    #[doc = "  This function sets the current gamma ramp for the specified monitor.  The"]
    #[doc = "  original gamma ramp for that monitor is saved by GLFW the first time this"]
    #[doc = "  function is called and is restored by @ref glfwTerminate."]
    #[doc = ""]
    #[doc = "  The software controlled gamma ramp is applied _in addition_ to the hardware"]
    #[doc = "  gamma correction, which today is usually an approximation of sRGB gamma."]
    #[doc = "  This means that setting a perfectly linear ramp, or gamma 1.0, will produce"]
    #[doc = "  the default (usually sRGB-like) behavior."]
    #[doc = ""]
    #[doc = "  For gamma correct rendering with OpenGL or OpenGL ES, see the @ref"]
    #[doc = "  GLFW_SRGB_CAPABLE hint."]
    #[doc = ""]
    #[doc = "  @param[in] monitor The monitor whose gamma ramp to set."]
    #[doc = "  @param[in] ramp The gamma ramp to use."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark The size of the specified gamma ramp should match the size of the"]
    #[doc = "  current ramp for that monitor."]
    #[doc = ""]
    #[doc = "  @remark @win32 The gamma ramp size must be 256."]
    #[doc = ""]
    #[doc = "  @remark @wayland Gamma handling is a privileged protocol, this function"]
    #[doc = "  will thus never be implemented and emits @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The specified gamma ramp is copied before this function"]
    #[doc = "  returns."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref monitor_gamma"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup monitor"]
    pub fn glfwSetGammaRamp(monitor: *mut GLFWmonitor, ramp: *const GLFWgammaramp);
}
extern "C" {
    #[doc = " @brief Resets all window hints to their default values."]
    #[doc = ""]
    #[doc = "  This function resets all window hints to their"]
    #[doc = "  [default values](@ref window_hints_values)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_hints"]
    #[doc = "  @sa @ref glfwWindowHint"]
    #[doc = "  @sa @ref glfwWindowHintString"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwDefaultWindowHints();
}
extern "C" {
    #[doc = " @brief Sets the specified window hint to the desired value."]
    #[doc = ""]
    #[doc = "  This function sets hints for the next call to @ref glfwCreateWindow.  The"]
    #[doc = "  hints, once set, retain their values until changed by a call to this"]
    #[doc = "  function or @ref glfwDefaultWindowHints, or until the library is terminated."]
    #[doc = ""]
    #[doc = "  Only integer value hints can be set with this function.  String value hints"]
    #[doc = "  are set with @ref glfwWindowHintString."]
    #[doc = ""]
    #[doc = "  This function does not check whether the specified hint values are valid."]
    #[doc = "  If you set hints to invalid values this will instead be reported by the next"]
    #[doc = "  call to @ref glfwCreateWindow."]
    #[doc = ""]
    #[doc = "  Some hints are platform specific.  These may be set on any platform but they"]
    #[doc = "  will only affect their specific platform.  Other platforms will ignore them."]
    #[doc = "  Setting these hints requires no platform specific headers or functions."]
    #[doc = ""]
    #[doc = "  @param[in] hint The [window hint](@ref window_hints) to set."]
    #[doc = "  @param[in] value The new value of the window hint."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_INVALID_ENUM."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_hints"]
    #[doc = "  @sa @ref glfwWindowHintString"]
    #[doc = "  @sa @ref glfwDefaultWindowHints"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwOpenWindowHint`."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwWindowHint(hint: ::std::os::raw::c_int, value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Sets the specified window hint to the desired value."]
    #[doc = ""]
    #[doc = "  This function sets hints for the next call to @ref glfwCreateWindow.  The"]
    #[doc = "  hints, once set, retain their values until changed by a call to this"]
    #[doc = "  function or @ref glfwDefaultWindowHints, or until the library is terminated."]
    #[doc = ""]
    #[doc = "  Only string type hints can be set with this function.  Integer value hints"]
    #[doc = "  are set with @ref glfwWindowHint."]
    #[doc = ""]
    #[doc = "  This function does not check whether the specified hint values are valid."]
    #[doc = "  If you set hints to invalid values this will instead be reported by the next"]
    #[doc = "  call to @ref glfwCreateWindow."]
    #[doc = ""]
    #[doc = "  Some hints are platform specific.  These may be set on any platform but they"]
    #[doc = "  will only affect their specific platform.  Other platforms will ignore them."]
    #[doc = "  Setting these hints requires no platform specific headers or functions."]
    #[doc = ""]
    #[doc = "  @param[in] hint The [window hint](@ref window_hints) to set."]
    #[doc = "  @param[in] value The new value of the window hint."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_INVALID_ENUM."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The specified string is copied before this function"]
    #[doc = "  returns."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_hints"]
    #[doc = "  @sa @ref glfwWindowHint"]
    #[doc = "  @sa @ref glfwDefaultWindowHints"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwWindowHintString(hint: ::std::os::raw::c_int, value: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @brief Creates a window and its associated context."]
    #[doc = ""]
    #[doc = "  This function creates a window and its associated OpenGL or OpenGL ES"]
    #[doc = "  context.  Most of the options controlling how the window and its context"]
    #[doc = "  should be created are specified with [window hints](@ref window_hints)."]
    #[doc = ""]
    #[doc = "  Successful creation does not change which context is current.  Before you"]
    #[doc = "  can use the newly created context, you need to"]
    #[doc = "  [make it current](@ref context_current).  For information about the `share`"]
    #[doc = "  parameter, see @ref context_sharing."]
    #[doc = ""]
    #[doc = "  The created window, framebuffer and context may differ from what you"]
    #[doc = "  requested, as not all parameters and hints are"]
    #[doc = "  [hard constraints](@ref window_hints_hard).  This includes the size of the"]
    #[doc = "  window, especially for full screen windows.  To query the actual attributes"]
    #[doc = "  of the created window, framebuffer and context, see @ref"]
    #[doc = "  glfwGetWindowAttrib, @ref glfwGetWindowSize and @ref glfwGetFramebufferSize."]
    #[doc = ""]
    #[doc = "  To create a full screen window, you need to specify the monitor the window"]
    #[doc = "  will cover.  If no monitor is specified, the window will be windowed mode."]
    #[doc = "  Unless you have a way for the user to choose a specific monitor, it is"]
    #[doc = "  recommended that you pick the primary monitor.  For more information on how"]
    #[doc = "  to query connected monitors, see @ref monitor_monitors."]
    #[doc = ""]
    #[doc = "  For full screen windows, the specified size becomes the resolution of the"]
    #[doc = "  window's _desired video mode_.  As long as a full screen window is not"]
    #[doc = "  iconified, the supported video mode most closely matching the desired video"]
    #[doc = "  mode is set for the specified monitor.  For more information about full"]
    #[doc = "  screen windows, including the creation of so called _windowed full screen_"]
    #[doc = "  or _borderless full screen_ windows, see @ref window_windowed_full_screen."]
    #[doc = ""]
    #[doc = "  Once you have created the window, you can switch it between windowed and"]
    #[doc = "  full screen mode with @ref glfwSetWindowMonitor.  This will not affect its"]
    #[doc = "  OpenGL or OpenGL ES context."]
    #[doc = ""]
    #[doc = "  By default, newly created windows use the placement recommended by the"]
    #[doc = "  window system.  To create the window at a specific position, make it"]
    #[doc = "  initially invisible using the [GLFW_VISIBLE](@ref GLFW_VISIBLE_hint) window"]
    #[doc = "  hint, set its [position](@ref window_pos) and then [show](@ref window_hide)"]
    #[doc = "  it."]
    #[doc = ""]
    #[doc = "  As long as at least one full screen window is not iconified, the screensaver"]
    #[doc = "  is prohibited from starting."]
    #[doc = ""]
    #[doc = "  Window systems put limits on window sizes.  Very large or very small window"]
    #[doc = "  dimensions may be overridden by the window system on creation.  Check the"]
    #[doc = "  actual [size](@ref window_size) after creation."]
    #[doc = ""]
    #[doc = "  The [swap interval](@ref buffer_swap) is not set during window creation and"]
    #[doc = "  the initial value may vary depending on driver settings and defaults."]
    #[doc = ""]
    #[doc = "  @param[in] width The desired width, in screen coordinates, of the window."]
    #[doc = "  This must be greater than zero."]
    #[doc = "  @param[in] height The desired height, in screen coordinates, of the window."]
    #[doc = "  This must be greater than zero."]
    #[doc = "  @param[in] title The initial, UTF-8 encoded window title."]
    #[doc = "  @param[in] monitor The monitor to use for full screen mode, or `NULL` for"]
    #[doc = "  windowed mode."]
    #[doc = "  @param[in] share The window whose context to share resources with, or `NULL`"]
    #[doc = "  to not share resources."]
    #[doc = "  @return The handle of the created window, or `NULL` if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_ENUM, @ref GLFW_INVALID_VALUE, @ref GLFW_API_UNAVAILABLE, @ref"]
    #[doc = "  GLFW_VERSION_UNAVAILABLE, @ref GLFW_FORMAT_UNAVAILABLE and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark @win32 Window creation will fail if the Microsoft GDI software"]
    #[doc = "  OpenGL implementation is the only one available."]
    #[doc = ""]
    #[doc = "  @remark @win32 If the executable has an icon resource named `GLFW_ICON,` it"]
    #[doc = "  will be set as the initial icon for the window.  If no such icon is present,"]
    #[doc = "  the `IDI_APPLICATION` icon will be used instead.  To set a different icon,"]
    #[doc = "  see @ref glfwSetWindowIcon."]
    #[doc = ""]
    #[doc = "  @remark @win32 The context to share resources with must not be current on"]
    #[doc = "  any other thread."]
    #[doc = ""]
    #[doc = "  @remark @macos The OS only supports forward-compatible core profile contexts"]
    #[doc = "  for OpenGL versions 3.2 and later.  Before creating an OpenGL context of"]
    #[doc = "  version 3.2 or later you must set the"]
    #[doc = "  [GLFW_OPENGL_FORWARD_COMPAT](@ref GLFW_OPENGL_FORWARD_COMPAT_hint) and"]
    #[doc = "  [GLFW_OPENGL_PROFILE](@ref GLFW_OPENGL_PROFILE_hint) hints accordingly."]
    #[doc = "  OpenGL 3.0 and 3.1 contexts are not supported at all on macOS."]
    #[doc = ""]
    #[doc = "  @remark @macos The GLFW window has no icon, as it is not a document"]
    #[doc = "  window, but the dock icon will be the same as the application bundle's icon."]
    #[doc = "  For more information on bundles, see the"]
    #[doc = "  [Bundle Programming Guide](https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFBundles/)"]
    #[doc = "  in the Mac Developer Library."]
    #[doc = ""]
    #[doc = "  @remark @macos The first time a window is created the menu bar is created."]
    #[doc = "  If GLFW finds a `MainMenu.nib` it is loaded and assumed to contain a menu"]
    #[doc = "  bar.  Otherwise a minimal menu bar is created manually with common commands"]
    #[doc = "  like Hide, Quit and About.  The About entry opens a minimal about dialog"]
    #[doc = "  with information from the application's bundle.  Menu bar creation can be"]
    #[doc = "  disabled entirely with the @ref GLFW_COCOA_MENUBAR init hint."]
    #[doc = ""]
    #[doc = "  @remark @macos On OS X 10.10 and later the window frame will not be rendered"]
    #[doc = "  at full resolution on Retina displays unless the"]
    #[doc = "  [GLFW_COCOA_RETINA_FRAMEBUFFER](@ref GLFW_COCOA_RETINA_FRAMEBUFFER_hint)"]
    #[doc = "  hint is `GLFW_TRUE` and the `NSHighResolutionCapable` key is enabled in the"]
    #[doc = "  application bundle's `Info.plist`.  For more information, see"]
    #[doc = "  [High Resolution Guidelines for OS X](https://developer.apple.com/library/mac/documentation/GraphicsAnimation/Conceptual/HighResolutionOSX/Explained/Explained.html)"]
    #[doc = "  in the Mac Developer Library.  The GLFW test and example programs use"]
    #[doc = "  a custom `Info.plist` template for this, which can be found as"]
    #[doc = "  `CMake/MacOSXBundleInfo.plist.in` in the source tree."]
    #[doc = ""]
    #[doc = "  @remark @macos When activating frame autosaving with"]
    #[doc = "  [GLFW_COCOA_FRAME_NAME](@ref GLFW_COCOA_FRAME_NAME_hint), the specified"]
    #[doc = "  window size and position may be overridden by previously saved values."]
    #[doc = ""]
    #[doc = "  @remark @x11 Some window managers will not respect the placement of"]
    #[doc = "  initially hidden windows."]
    #[doc = ""]
    #[doc = "  @remark @x11 Due to the asynchronous nature of X11, it may take a moment for"]
    #[doc = "  a window to reach its requested state.  This means you may not be able to"]
    #[doc = "  query the final size, position or other attributes directly after window"]
    #[doc = "  creation."]
    #[doc = ""]
    #[doc = "  @remark @x11 The class part of the `WM_CLASS` window property will by"]
    #[doc = "  default be set to the window title passed to this function.  The instance"]
    #[doc = "  part will use the contents of the `RESOURCE_NAME` environment variable, if"]
    #[doc = "  present and not empty, or fall back to the window title.  Set the"]
    #[doc = "  [GLFW_X11_CLASS_NAME](@ref GLFW_X11_CLASS_NAME_hint) and"]
    #[doc = "  [GLFW_X11_INSTANCE_NAME](@ref GLFW_X11_INSTANCE_NAME_hint) window hints to"]
    #[doc = "  override this."]
    #[doc = ""]
    #[doc = "  @remark @wayland Compositors should implement the xdg-decoration protocol"]
    #[doc = "  for GLFW to decorate the window properly.  If this protocol isn't"]
    #[doc = "  supported, or if the compositor prefers client-side decorations, a very"]
    #[doc = "  simple fallback frame will be drawn using the wp_viewporter protocol.  A"]
    #[doc = "  compositor can still emit close, maximize or fullscreen events, using for"]
    #[doc = "  instance a keybind mechanism.  If neither of these protocols is supported,"]
    #[doc = "  the window won't be decorated."]
    #[doc = ""]
    #[doc = "  @remark @wayland A full screen window will not attempt to change the mode,"]
    #[doc = "  no matter what the requested size or refresh rate."]
    #[doc = ""]
    #[doc = "  @remark @wayland Screensaver inhibition requires the idle-inhibit protocol"]
    #[doc = "  to be implemented in the user's compositor."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_creation"]
    #[doc = "  @sa @ref glfwDestroyWindow"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwOpenWindow`."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwCreateWindow(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        title: *const ::std::os::raw::c_char,
        monitor: *mut GLFWmonitor,
        share: *mut GLFWwindow,
    ) -> *mut GLFWwindow;
}
extern "C" {
    #[doc = " @brief Destroys the specified window and its context."]
    #[doc = ""]
    #[doc = "  This function destroys the specified window and its context.  On calling"]
    #[doc = "  this function, no further callbacks will be called for that window."]
    #[doc = ""]
    #[doc = "  If the context of the specified window is current on the main thread, it is"]
    #[doc = "  detached before being destroyed."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to destroy."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @note The context of the specified window must not be current on any other"]
    #[doc = "  thread when this function is called."]
    #[doc = ""]
    #[doc = "  @reentrancy This function must not be called from a callback."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_creation"]
    #[doc = "  @sa @ref glfwCreateWindow"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwCloseWindow`."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwDestroyWindow(window: *mut GLFWwindow);
}
extern "C" {
    #[doc = " @brief Checks the close flag of the specified window."]
    #[doc = ""]
    #[doc = "  This function returns the value of the close flag of the specified window."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to query."]
    #[doc = "  @return The value of the close flag."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread.  Access is not"]
    #[doc = "  synchronized."]
    #[doc = ""]
    #[doc = "  @sa @ref window_close"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwWindowShouldClose(window: *mut GLFWwindow) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Sets the close flag of the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the value of the close flag of the specified window."]
    #[doc = "  This can be used to override the user's attempt to close the window, or"]
    #[doc = "  to signal that it should be closed."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose flag to change."]
    #[doc = "  @param[in] value The new value."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread.  Access is not"]
    #[doc = "  synchronized."]
    #[doc = ""]
    #[doc = "  @sa @ref window_close"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowShouldClose(window: *mut GLFWwindow, value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Sets the title of the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the window title, encoded as UTF-8, of the specified"]
    #[doc = "  window."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose title to change."]
    #[doc = "  @param[in] title The UTF-8 encoded window title."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark @macos The window title will not be updated until the next time you"]
    #[doc = "  process events."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_title"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = "  @glfw3 Added window handle parameter."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowTitle(window: *mut GLFWwindow, title: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @brief Sets the icon for the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the icon of the specified window.  If passed an array of"]
    #[doc = "  candidate images, those of or closest to the sizes desired by the system are"]
    #[doc = "  selected.  If no images are specified, the window reverts to its default"]
    #[doc = "  icon."]
    #[doc = ""]
    #[doc = "  The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight"]
    #[doc = "  bits per channel with the red channel first.  They are arranged canonically"]
    #[doc = "  as packed sequential rows, starting from the top-left corner."]
    #[doc = ""]
    #[doc = "  The desired image sizes varies depending on platform and system settings."]
    #[doc = "  The selected images will be rescaled as needed.  Good sizes include 16x16,"]
    #[doc = "  32x32 and 48x48."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose icon to set."]
    #[doc = "  @param[in] count The number of images in the specified array, or zero to"]
    #[doc = "  revert to the default window icon."]
    #[doc = "  @param[in] images The images to create the icon from.  This is ignored if"]
    #[doc = "  count is zero."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The specified image data is copied before this function"]
    #[doc = "  returns."]
    #[doc = ""]
    #[doc = "  @remark @macos The GLFW window has no icon, as it is not a document"]
    #[doc = "  window, so this function does nothing.  The dock icon will be the same as"]
    #[doc = "  the application bundle's icon.  For more information on bundles, see the"]
    #[doc = "  [Bundle Programming Guide](https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFBundles/)"]
    #[doc = "  in the Mac Developer Library."]
    #[doc = ""]
    #[doc = "  @remark @wayland There is no existing protocol to change an icon, the"]
    #[doc = "  window will thus inherit the one defined in the application's desktop file."]
    #[doc = "  This function always emits @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_icon"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowIcon(
        window: *mut GLFWwindow,
        count: ::std::os::raw::c_int,
        images: *const GLFWimage,
    );
}
extern "C" {
    #[doc = " @brief Retrieves the position of the content area of the specified window."]
    #[doc = ""]
    #[doc = "  This function retrieves the position, in screen coordinates, of the"]
    #[doc = "  upper-left corner of the content area of the specified window."]
    #[doc = ""]
    #[doc = "  Any or all of the position arguments may be `NULL`.  If an error occurs, all"]
    #[doc = "  non-`NULL` position arguments will be set to zero."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to query."]
    #[doc = "  @param[out] xpos Where to store the x-coordinate of the upper-left corner of"]
    #[doc = "  the content area, or `NULL`."]
    #[doc = "  @param[out] ypos Where to store the y-coordinate of the upper-left corner of"]
    #[doc = "  the content area, or `NULL`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark @wayland There is no way for an application to retrieve the global"]
    #[doc = "  position of its windows, this function will always emit @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_pos"]
    #[doc = "  @sa @ref glfwSetWindowPos"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwGetWindowPos(
        window: *mut GLFWwindow,
        xpos: *mut ::std::os::raw::c_int,
        ypos: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the position of the content area of the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the position, in screen coordinates, of the upper-left"]
    #[doc = "  corner of the content area of the specified windowed mode window.  If the"]
    #[doc = "  window is a full screen window, this function does nothing."]
    #[doc = ""]
    #[doc = "  __Do not use this function__ to move an already visible window unless you"]
    #[doc = "  have very good reasons for doing so, as it will confuse and annoy the user."]
    #[doc = ""]
    #[doc = "  The window manager may put limits on what positions are allowed.  GLFW"]
    #[doc = "  cannot and should not override these limits."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to query."]
    #[doc = "  @param[in] xpos The x-coordinate of the upper-left corner of the content area."]
    #[doc = "  @param[in] ypos The y-coordinate of the upper-left corner of the content area."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark @wayland There is no way for an application to set the global"]
    #[doc = "  position of its windows, this function will always emit @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_pos"]
    #[doc = "  @sa @ref glfwGetWindowPos"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = "  @glfw3 Added window handle parameter."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowPos(
        window: *mut GLFWwindow,
        xpos: ::std::os::raw::c_int,
        ypos: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Retrieves the size of the content area of the specified window."]
    #[doc = ""]
    #[doc = "  This function retrieves the size, in screen coordinates, of the content area"]
    #[doc = "  of the specified window.  If you wish to retrieve the size of the"]
    #[doc = "  framebuffer of the window in pixels, see @ref glfwGetFramebufferSize."]
    #[doc = ""]
    #[doc = "  Any or all of the size arguments may be `NULL`.  If an error occurs, all"]
    #[doc = "  non-`NULL` size arguments will be set to zero."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose size to retrieve."]
    #[doc = "  @param[out] width Where to store the width, in screen coordinates, of the"]
    #[doc = "  content area, or `NULL`."]
    #[doc = "  @param[out] height Where to store the height, in screen coordinates, of the"]
    #[doc = "  content area, or `NULL`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_size"]
    #[doc = "  @sa @ref glfwSetWindowSize"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = "  @glfw3 Added window handle parameter."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwGetWindowSize(
        window: *mut GLFWwindow,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the size limits of the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the size limits of the content area of the specified"]
    #[doc = "  window.  If the window is full screen, the size limits only take effect"]
    #[doc = "  once it is made windowed.  If the window is not resizable, this function"]
    #[doc = "  does nothing."]
    #[doc = ""]
    #[doc = "  The size limits are applied immediately to a windowed mode window and may"]
    #[doc = "  cause it to be resized."]
    #[doc = ""]
    #[doc = "  The maximum dimensions must be greater than or equal to the minimum"]
    #[doc = "  dimensions and all must be greater than or equal to zero."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to set limits for."]
    #[doc = "  @param[in] minwidth The minimum width, in screen coordinates, of the content"]
    #[doc = "  area, or `GLFW_DONT_CARE`."]
    #[doc = "  @param[in] minheight The minimum height, in screen coordinates, of the"]
    #[doc = "  content area, or `GLFW_DONT_CARE`."]
    #[doc = "  @param[in] maxwidth The maximum width, in screen coordinates, of the content"]
    #[doc = "  area, or `GLFW_DONT_CARE`."]
    #[doc = "  @param[in] maxheight The maximum height, in screen coordinates, of the"]
    #[doc = "  content area, or `GLFW_DONT_CARE`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark If you set size limits and an aspect ratio that conflict, the"]
    #[doc = "  results are undefined."]
    #[doc = ""]
    #[doc = "  @remark @wayland The size limits will not be applied until the window is"]
    #[doc = "  actually resized, either by the user or by the compositor."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_sizelimits"]
    #[doc = "  @sa @ref glfwSetWindowAspectRatio"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowSizeLimits(
        window: *mut GLFWwindow,
        minwidth: ::std::os::raw::c_int,
        minheight: ::std::os::raw::c_int,
        maxwidth: ::std::os::raw::c_int,
        maxheight: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the aspect ratio of the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the required aspect ratio of the content area of the"]
    #[doc = "  specified window.  If the window is full screen, the aspect ratio only takes"]
    #[doc = "  effect once it is made windowed.  If the window is not resizable, this"]
    #[doc = "  function does nothing."]
    #[doc = ""]
    #[doc = "  The aspect ratio is specified as a numerator and a denominator and both"]
    #[doc = "  values must be greater than zero.  For example, the common 16:9 aspect ratio"]
    #[doc = "  is specified as 16 and 9, respectively."]
    #[doc = ""]
    #[doc = "  If the numerator and denominator is set to `GLFW_DONT_CARE` then the aspect"]
    #[doc = "  ratio limit is disabled."]
    #[doc = ""]
    #[doc = "  The aspect ratio is applied immediately to a windowed mode window and may"]
    #[doc = "  cause it to be resized."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to set limits for."]
    #[doc = "  @param[in] numer The numerator of the desired aspect ratio, or"]
    #[doc = "  `GLFW_DONT_CARE`."]
    #[doc = "  @param[in] denom The denominator of the desired aspect ratio, or"]
    #[doc = "  `GLFW_DONT_CARE`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark If you set size limits and an aspect ratio that conflict, the"]
    #[doc = "  results are undefined."]
    #[doc = ""]
    #[doc = "  @remark @wayland The aspect ratio will not be applied until the window is"]
    #[doc = "  actually resized, either by the user or by the compositor."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_sizelimits"]
    #[doc = "  @sa @ref glfwSetWindowSizeLimits"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowAspectRatio(
        window: *mut GLFWwindow,
        numer: ::std::os::raw::c_int,
        denom: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the size of the content area of the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the size, in screen coordinates, of the content area of"]
    #[doc = "  the specified window."]
    #[doc = ""]
    #[doc = "  For full screen windows, this function updates the resolution of its desired"]
    #[doc = "  video mode and switches to the video mode closest to it, without affecting"]
    #[doc = "  the window's context.  As the context is unaffected, the bit depths of the"]
    #[doc = "  framebuffer remain unchanged."]
    #[doc = ""]
    #[doc = "  If you wish to update the refresh rate of the desired video mode in addition"]
    #[doc = "  to its resolution, see @ref glfwSetWindowMonitor."]
    #[doc = ""]
    #[doc = "  The window manager may put limits on what sizes are allowed.  GLFW cannot"]
    #[doc = "  and should not override these limits."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to resize."]
    #[doc = "  @param[in] width The desired width, in screen coordinates, of the window"]
    #[doc = "  content area."]
    #[doc = "  @param[in] height The desired height, in screen coordinates, of the window"]
    #[doc = "  content area."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark @wayland A full screen window will not attempt to change the mode,"]
    #[doc = "  no matter what the requested size."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_size"]
    #[doc = "  @sa @ref glfwGetWindowSize"]
    #[doc = "  @sa @ref glfwSetWindowMonitor"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = "  @glfw3 Added window handle parameter."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowSize(
        window: *mut GLFWwindow,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Retrieves the size of the framebuffer of the specified window."]
    #[doc = ""]
    #[doc = "  This function retrieves the size, in pixels, of the framebuffer of the"]
    #[doc = "  specified window.  If you wish to retrieve the size of the window in screen"]
    #[doc = "  coordinates, see @ref glfwGetWindowSize."]
    #[doc = ""]
    #[doc = "  Any or all of the size arguments may be `NULL`.  If an error occurs, all"]
    #[doc = "  non-`NULL` size arguments will be set to zero."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose framebuffer to query."]
    #[doc = "  @param[out] width Where to store the width, in pixels, of the framebuffer,"]
    #[doc = "  or `NULL`."]
    #[doc = "  @param[out] height Where to store the height, in pixels, of the framebuffer,"]
    #[doc = "  or `NULL`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_fbsize"]
    #[doc = "  @sa @ref glfwSetFramebufferSizeCallback"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwGetFramebufferSize(
        window: *mut GLFWwindow,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Retrieves the size of the frame of the window."]
    #[doc = ""]
    #[doc = "  This function retrieves the size, in screen coordinates, of each edge of the"]
    #[doc = "  frame of the specified window.  This size includes the title bar, if the"]
    #[doc = "  window has one.  The size of the frame may vary depending on the"]
    #[doc = "  [window-related hints](@ref window_hints_wnd) used to create it."]
    #[doc = ""]
    #[doc = "  Because this function retrieves the size of each window frame edge and not"]
    #[doc = "  the offset along a particular coordinate axis, the retrieved values will"]
    #[doc = "  always be zero or positive."]
    #[doc = ""]
    #[doc = "  Any or all of the size arguments may be `NULL`.  If an error occurs, all"]
    #[doc = "  non-`NULL` size arguments will be set to zero."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose frame size to query."]
    #[doc = "  @param[out] left Where to store the size, in screen coordinates, of the left"]
    #[doc = "  edge of the window frame, or `NULL`."]
    #[doc = "  @param[out] top Where to store the size, in screen coordinates, of the top"]
    #[doc = "  edge of the window frame, or `NULL`."]
    #[doc = "  @param[out] right Where to store the size, in screen coordinates, of the"]
    #[doc = "  right edge of the window frame, or `NULL`."]
    #[doc = "  @param[out] bottom Where to store the size, in screen coordinates, of the"]
    #[doc = "  bottom edge of the window frame, or `NULL`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_size"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.1."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwGetWindowFrameSize(
        window: *mut GLFWwindow,
        left: *mut ::std::os::raw::c_int,
        top: *mut ::std::os::raw::c_int,
        right: *mut ::std::os::raw::c_int,
        bottom: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Retrieves the content scale for the specified window."]
    #[doc = ""]
    #[doc = "  This function retrieves the content scale for the specified window.  The"]
    #[doc = "  content scale is the ratio between the current DPI and the platform's"]
    #[doc = "  default DPI.  This is especially important for text and any UI elements.  If"]
    #[doc = "  the pixel dimensions of your UI scaled by this look appropriate on your"]
    #[doc = "  machine then it should appear at a reasonable size on other machines"]
    #[doc = "  regardless of their DPI and scaling settings.  This relies on the system DPI"]
    #[doc = "  and scaling settings being somewhat correct."]
    #[doc = ""]
    #[doc = "  On systems where each monitors can have its own content scale, the window"]
    #[doc = "  content scale will depend on which monitor the system considers the window"]
    #[doc = "  to be on."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to query."]
    #[doc = "  @param[out] xscale Where to store the x-axis content scale, or `NULL`."]
    #[doc = "  @param[out] yscale Where to store the y-axis content scale, or `NULL`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_scale"]
    #[doc = "  @sa @ref glfwSetWindowContentScaleCallback"]
    #[doc = "  @sa @ref glfwGetMonitorContentScale"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwGetWindowContentScale(window: *mut GLFWwindow, xscale: *mut f32, yscale: *mut f32);
}
extern "C" {
    #[doc = " @brief Returns the opacity of the whole window."]
    #[doc = ""]
    #[doc = "  This function returns the opacity of the window, including any decorations."]
    #[doc = ""]
    #[doc = "  The opacity (or alpha) value is a positive finite number between zero and"]
    #[doc = "  one, where zero is fully transparent and one is fully opaque.  If the system"]
    #[doc = "  does not support whole window transparency, this function always returns one."]
    #[doc = ""]
    #[doc = "  The initial opacity value for newly created windows is one."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to query."]
    #[doc = "  @return The opacity value of the specified window."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_transparency"]
    #[doc = "  @sa @ref glfwSetWindowOpacity"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwGetWindowOpacity(window: *mut GLFWwindow) -> f32;
}
extern "C" {
    #[doc = " @brief Sets the opacity of the whole window."]
    #[doc = ""]
    #[doc = "  This function sets the opacity of the window, including any decorations."]
    #[doc = ""]
    #[doc = "  The opacity (or alpha) value is a positive finite number between zero and"]
    #[doc = "  one, where zero is fully transparent and one is fully opaque."]
    #[doc = ""]
    #[doc = "  The initial opacity value for newly created windows is one."]
    #[doc = ""]
    #[doc = "  A window created with framebuffer transparency may not use whole window"]
    #[doc = "  transparency.  The results of doing this are undefined."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to set the opacity for."]
    #[doc = "  @param[in] opacity The desired opacity of the specified window."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_transparency"]
    #[doc = "  @sa @ref glfwGetWindowOpacity"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowOpacity(window: *mut GLFWwindow, opacity: f32);
}
extern "C" {
    #[doc = " @brief Iconifies the specified window."]
    #[doc = ""]
    #[doc = "  This function iconifies (minimizes) the specified window if it was"]
    #[doc = "  previously restored.  If the window is already iconified, this function does"]
    #[doc = "  nothing."]
    #[doc = ""]
    #[doc = "  If the specified window is a full screen window, the original monitor"]
    #[doc = "  resolution is restored until the window is restored."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to iconify."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark @wayland There is no concept of iconification in wl_shell, this"]
    #[doc = "  function will emit @ref GLFW_PLATFORM_ERROR when using this deprecated"]
    #[doc = "  protocol."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_iconify"]
    #[doc = "  @sa @ref glfwRestoreWindow"]
    #[doc = "  @sa @ref glfwMaximizeWindow"]
    #[doc = ""]
    #[doc = "  @since Added in version 2.1."]
    #[doc = "  @glfw3 Added window handle parameter."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwIconifyWindow(window: *mut GLFWwindow);
}
extern "C" {
    #[doc = " @brief Restores the specified window."]
    #[doc = ""]
    #[doc = "  This function restores the specified window if it was previously iconified"]
    #[doc = "  (minimized) or maximized.  If the window is already restored, this function"]
    #[doc = "  does nothing."]
    #[doc = ""]
    #[doc = "  If the specified window is a full screen window, the resolution chosen for"]
    #[doc = "  the window is restored on the selected monitor."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to restore."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_iconify"]
    #[doc = "  @sa @ref glfwIconifyWindow"]
    #[doc = "  @sa @ref glfwMaximizeWindow"]
    #[doc = ""]
    #[doc = "  @since Added in version 2.1."]
    #[doc = "  @glfw3 Added window handle parameter."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwRestoreWindow(window: *mut GLFWwindow);
}
extern "C" {
    #[doc = " @brief Maximizes the specified window."]
    #[doc = ""]
    #[doc = "  This function maximizes the specified window if it was previously not"]
    #[doc = "  maximized.  If the window is already maximized, this function does nothing."]
    #[doc = ""]
    #[doc = "  If the specified window is a full screen window, this function does nothing."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to maximize."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @par Thread Safety"]
    #[doc = "  This function may only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_iconify"]
    #[doc = "  @sa @ref glfwIconifyWindow"]
    #[doc = "  @sa @ref glfwRestoreWindow"]
    #[doc = ""]
    #[doc = "  @since Added in GLFW 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwMaximizeWindow(window: *mut GLFWwindow);
}
extern "C" {
    #[doc = " @brief Makes the specified window visible."]
    #[doc = ""]
    #[doc = "  This function makes the specified window visible if it was previously"]
    #[doc = "  hidden.  If the window is already visible or is in full screen mode, this"]
    #[doc = "  function does nothing."]
    #[doc = ""]
    #[doc = "  By default, windowed mode windows are focused when shown"]
    #[doc = "  Set the [GLFW_FOCUS_ON_SHOW](@ref GLFW_FOCUS_ON_SHOW_hint) window hint"]
    #[doc = "  to change this behavior for all newly created windows, or change the"]
    #[doc = "  behavior for an existing window with @ref glfwSetWindowAttrib."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to make visible."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_hide"]
    #[doc = "  @sa @ref glfwHideWindow"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwShowWindow(window: *mut GLFWwindow);
}
extern "C" {
    #[doc = " @brief Hides the specified window."]
    #[doc = ""]
    #[doc = "  This function hides the specified window if it was previously visible.  If"]
    #[doc = "  the window is already hidden or is in full screen mode, this function does"]
    #[doc = "  nothing."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to hide."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_hide"]
    #[doc = "  @sa @ref glfwShowWindow"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwHideWindow(window: *mut GLFWwindow);
}
extern "C" {
    #[doc = " @brief Brings the specified window to front and sets input focus."]
    #[doc = ""]
    #[doc = "  This function brings the specified window to front and sets input focus."]
    #[doc = "  The window should already be visible and not iconified."]
    #[doc = ""]
    #[doc = "  By default, both windowed and full screen mode windows are focused when"]
    #[doc = "  initially created.  Set the [GLFW_FOCUSED](@ref GLFW_FOCUSED_hint) to"]
    #[doc = "  disable this behavior."]
    #[doc = ""]
    #[doc = "  Also by default, windowed mode windows are focused when shown"]
    #[doc = "  with @ref glfwShowWindow. Set the"]
    #[doc = "  [GLFW_FOCUS_ON_SHOW](@ref GLFW_FOCUS_ON_SHOW_hint) to disable this behavior."]
    #[doc = ""]
    #[doc = "  __Do not use this function__ to steal focus from other applications unless"]
    #[doc = "  you are certain that is what the user wants.  Focus stealing can be"]
    #[doc = "  extremely disruptive."]
    #[doc = ""]
    #[doc = "  For a less disruptive way of getting the user's attention, see"]
    #[doc = "  [attention requests](@ref window_attention)."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to give input focus."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark @wayland It is not possible for an application to bring its windows"]
    #[doc = "  to front, this function will always emit @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_focus"]
    #[doc = "  @sa @ref window_attention"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwFocusWindow(window: *mut GLFWwindow);
}
extern "C" {
    #[doc = " @brief Requests user attention to the specified window."]
    #[doc = ""]
    #[doc = "  This function requests user attention to the specified window.  On"]
    #[doc = "  platforms where this is not supported, attention is requested to the"]
    #[doc = "  application as a whole."]
    #[doc = ""]
    #[doc = "  Once the user has given attention, usually by focusing the window or"]
    #[doc = "  application, the system will end the request automatically."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to request attention to."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark @macos Attention is requested to the application as a whole, not the"]
    #[doc = "  specific window."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_attention"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwRequestWindowAttention(window: *mut GLFWwindow);
}
extern "C" {
    #[doc = " @brief Returns the monitor that the window uses for full screen mode."]
    #[doc = ""]
    #[doc = "  This function returns the handle of the monitor that the specified window is"]
    #[doc = "  in full screen on."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to query."]
    #[doc = "  @return The monitor, or `NULL` if the window is in windowed mode or an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_monitor"]
    #[doc = "  @sa @ref glfwSetWindowMonitor"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwGetWindowMonitor(window: *mut GLFWwindow) -> *mut GLFWmonitor;
}
extern "C" {
    #[doc = " @brief Sets the mode, monitor, video mode and placement of a window."]
    #[doc = ""]
    #[doc = "  This function sets the monitor that the window uses for full screen mode or,"]
    #[doc = "  if the monitor is `NULL`, makes it windowed mode."]
    #[doc = ""]
    #[doc = "  When setting a monitor, this function updates the width, height and refresh"]
    #[doc = "  rate of the desired video mode and switches to the video mode closest to it."]
    #[doc = "  The window position is ignored when setting a monitor."]
    #[doc = ""]
    #[doc = "  When the monitor is `NULL`, the position, width and height are used to"]
    #[doc = "  place the window content area.  The refresh rate is ignored when no monitor"]
    #[doc = "  is specified."]
    #[doc = ""]
    #[doc = "  If you only wish to update the resolution of a full screen window or the"]
    #[doc = "  size of a windowed mode window, see @ref glfwSetWindowSize."]
    #[doc = ""]
    #[doc = "  When a window transitions from full screen to windowed mode, this function"]
    #[doc = "  restores any previous window settings such as whether it is decorated,"]
    #[doc = "  floating, resizable, has size or aspect ratio limits, etc."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose monitor, size or video mode to set."]
    #[doc = "  @param[in] monitor The desired monitor, or `NULL` to set windowed mode."]
    #[doc = "  @param[in] xpos The desired x-coordinate of the upper-left corner of the"]
    #[doc = "  content area."]
    #[doc = "  @param[in] ypos The desired y-coordinate of the upper-left corner of the"]
    #[doc = "  content area."]
    #[doc = "  @param[in] width The desired with, in screen coordinates, of the content"]
    #[doc = "  area or video mode."]
    #[doc = "  @param[in] height The desired height, in screen coordinates, of the content"]
    #[doc = "  area or video mode."]
    #[doc = "  @param[in] refreshRate The desired refresh rate, in Hz, of the video mode,"]
    #[doc = "  or `GLFW_DONT_CARE`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark The OpenGL or OpenGL ES context will not be destroyed or otherwise"]
    #[doc = "  affected by any resizing or mode switching, although you may need to update"]
    #[doc = "  your viewport if the framebuffer size has changed."]
    #[doc = ""]
    #[doc = "  @remark @wayland The desired window position is ignored, as there is no way"]
    #[doc = "  for an application to set this property."]
    #[doc = ""]
    #[doc = "  @remark @wayland Setting the window to full screen will not attempt to"]
    #[doc = "  change the mode, no matter what the requested size or refresh rate."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_monitor"]
    #[doc = "  @sa @ref window_full_screen"]
    #[doc = "  @sa @ref glfwGetWindowMonitor"]
    #[doc = "  @sa @ref glfwSetWindowSize"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowMonitor(
        window: *mut GLFWwindow,
        monitor: *mut GLFWmonitor,
        xpos: ::std::os::raw::c_int,
        ypos: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        refreshRate: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Returns an attribute of the specified window."]
    #[doc = ""]
    #[doc = "  This function returns the value of an attribute of the specified window or"]
    #[doc = "  its OpenGL or OpenGL ES context."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to query."]
    #[doc = "  @param[in] attrib The [window attribute](@ref window_attribs) whose value to"]
    #[doc = "  return."]
    #[doc = "  @return The value of the attribute, or zero if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark Framebuffer related hints are not window attributes.  See @ref"]
    #[doc = "  window_attribs_fb for more information."]
    #[doc = ""]
    #[doc = "  @remark Zero is a valid value for many window and context related"]
    #[doc = "  attributes so you cannot use a return value of zero as an indication of"]
    #[doc = "  errors.  However, this function should not fail as long as it is passed"]
    #[doc = "  valid arguments and the library has been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_attribs"]
    #[doc = "  @sa @ref glfwSetWindowAttrib"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwGetWindowParam` and"]
    #[doc = "  `glfwGetGLVersion`."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwGetWindowAttrib(
        window: *mut GLFWwindow,
        attrib: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Sets an attribute of the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the value of an attribute of the specified window."]
    #[doc = ""]
    #[doc = "  The supported attributes are [GLFW_DECORATED](@ref GLFW_DECORATED_attrib),"]
    #[doc = "  [GLFW_RESIZABLE](@ref GLFW_RESIZABLE_attrib),"]
    #[doc = "  [GLFW_FLOATING](@ref GLFW_FLOATING_attrib),"]
    #[doc = "  [GLFW_AUTO_ICONIFY](@ref GLFW_AUTO_ICONIFY_attrib) and"]
    #[doc = "  [GLFW_FOCUS_ON_SHOW](@ref GLFW_FOCUS_ON_SHOW_attrib)."]
    #[doc = ""]
    #[doc = "  Some of these attributes are ignored for full screen windows.  The new"]
    #[doc = "  value will take effect if the window is later made windowed."]
    #[doc = ""]
    #[doc = "  Some of these attributes are ignored for windowed mode windows.  The new"]
    #[doc = "  value will take effect if the window is later made full screen."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to set the attribute for."]
    #[doc = "  @param[in] attrib A supported window attribute."]
    #[doc = "  @param[in] value `GLFW_TRUE` or `GLFW_FALSE`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_ENUM, @ref GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark Calling @ref glfwGetWindowAttrib will always return the latest"]
    #[doc = "  value, even if that value is ignored by the current mode of the window."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_attribs"]
    #[doc = "  @sa @ref glfwGetWindowAttrib"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowAttrib(
        window: *mut GLFWwindow,
        attrib: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the user pointer of the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the user-defined pointer of the specified window.  The"]
    #[doc = "  current value is retained until the window is destroyed.  The initial value"]
    #[doc = "  is `NULL`."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose pointer to set."]
    #[doc = "  @param[in] pointer The new value."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread.  Access is not"]
    #[doc = "  synchronized."]
    #[doc = ""]
    #[doc = "  @sa @ref window_userptr"]
    #[doc = "  @sa @ref glfwGetWindowUserPointer"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowUserPointer(window: *mut GLFWwindow, pointer: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " @brief Returns the user pointer of the specified window."]
    #[doc = ""]
    #[doc = "  This function returns the current value of the user-defined pointer of the"]
    #[doc = "  specified window.  The initial value is `NULL`."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose pointer to return."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread.  Access is not"]
    #[doc = "  synchronized."]
    #[doc = ""]
    #[doc = "  @sa @ref window_userptr"]
    #[doc = "  @sa @ref glfwSetWindowUserPointer"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwGetWindowUserPointer(window: *mut GLFWwindow) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Sets the position callback for the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the position callback of the specified window, which is"]
    #[doc = "  called when the window is moved.  The callback is provided with the"]
    #[doc = "  position, in screen coordinates, of the upper-left corner of the content"]
    #[doc = "  area of the window."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] callback The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @callback_signature"]
    #[doc = "  @code"]
    #[doc = "  void function_name(GLFWwindow* window, int xpos, int ypos)"]
    #[doc = "  @endcode"]
    #[doc = "  For more information about the callback parameters, see the"]
    #[doc = "  [function pointer type](@ref GLFWwindowposfun)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @remark @wayland This callback will never be called, as there is no way for"]
    #[doc = "  an application to know its global position."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_pos"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowPosCallback(
        window: *mut GLFWwindow,
        callback: GLFWwindowposfun,
    ) -> GLFWwindowposfun;
}
extern "C" {
    #[doc = " @brief Sets the size callback for the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the size callback of the specified window, which is"]
    #[doc = "  called when the window is resized.  The callback is provided with the size,"]
    #[doc = "  in screen coordinates, of the content area of the window."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] callback The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @callback_signature"]
    #[doc = "  @code"]
    #[doc = "  void function_name(GLFWwindow* window, int width, int height)"]
    #[doc = "  @endcode"]
    #[doc = "  For more information about the callback parameters, see the"]
    #[doc = "  [function pointer type](@ref GLFWwindowsizefun)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_size"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = "  @glfw3 Added window handle parameter and return value."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowSizeCallback(
        window: *mut GLFWwindow,
        callback: GLFWwindowsizefun,
    ) -> GLFWwindowsizefun;
}
extern "C" {
    #[doc = " @brief Sets the close callback for the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the close callback of the specified window, which is"]
    #[doc = "  called when the user attempts to close the window, for example by clicking"]
    #[doc = "  the close widget in the title bar."]
    #[doc = ""]
    #[doc = "  The close flag is set before this callback is called, but you can modify it"]
    #[doc = "  at any time with @ref glfwSetWindowShouldClose."]
    #[doc = ""]
    #[doc = "  The close callback is not triggered by @ref glfwDestroyWindow."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] callback The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @callback_signature"]
    #[doc = "  @code"]
    #[doc = "  void function_name(GLFWwindow* window)"]
    #[doc = "  @endcode"]
    #[doc = "  For more information about the callback parameters, see the"]
    #[doc = "  [function pointer type](@ref GLFWwindowclosefun)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @remark @macos Selecting Quit from the application menu will trigger the"]
    #[doc = "  close callback for all windows."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_close"]
    #[doc = ""]
    #[doc = "  @since Added in version 2.5."]
    #[doc = "  @glfw3 Added window handle parameter and return value."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowCloseCallback(
        window: *mut GLFWwindow,
        callback: GLFWwindowclosefun,
    ) -> GLFWwindowclosefun;
}
extern "C" {
    #[doc = " @brief Sets the refresh callback for the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the refresh callback of the specified window, which is"]
    #[doc = "  called when the content area of the window needs to be redrawn, for example"]
    #[doc = "  if the window has been exposed after having been covered by another window."]
    #[doc = ""]
    #[doc = "  On compositing window systems such as Aero, Compiz, Aqua or Wayland, where"]
    #[doc = "  the window contents are saved off-screen, this callback may be called only"]
    #[doc = "  very infrequently or never at all."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] callback The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @callback_signature"]
    #[doc = "  @code"]
    #[doc = "  void function_name(GLFWwindow* window);"]
    #[doc = "  @endcode"]
    #[doc = "  For more information about the callback parameters, see the"]
    #[doc = "  [function pointer type](@ref GLFWwindowrefreshfun)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_refresh"]
    #[doc = ""]
    #[doc = "  @since Added in version 2.5."]
    #[doc = "  @glfw3 Added window handle parameter and return value."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowRefreshCallback(
        window: *mut GLFWwindow,
        callback: GLFWwindowrefreshfun,
    ) -> GLFWwindowrefreshfun;
}
extern "C" {
    #[doc = " @brief Sets the focus callback for the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the focus callback of the specified window, which is"]
    #[doc = "  called when the window gains or loses input focus."]
    #[doc = ""]
    #[doc = "  After the focus callback is called for a window that lost input focus,"]
    #[doc = "  synthetic key and mouse button release events will be generated for all such"]
    #[doc = "  that had been pressed.  For more information, see @ref glfwSetKeyCallback"]
    #[doc = "  and @ref glfwSetMouseButtonCallback."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] callback The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @callback_signature"]
    #[doc = "  @code"]
    #[doc = "  void function_name(GLFWwindow* window, int focused)"]
    #[doc = "  @endcode"]
    #[doc = "  For more information about the callback parameters, see the"]
    #[doc = "  [function pointer type](@ref GLFWwindowfocusfun)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_focus"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowFocusCallback(
        window: *mut GLFWwindow,
        callback: GLFWwindowfocusfun,
    ) -> GLFWwindowfocusfun;
}
extern "C" {
    #[doc = " @brief Sets the iconify callback for the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the iconification callback of the specified window, which"]
    #[doc = "  is called when the window is iconified or restored."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] callback The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @callback_signature"]
    #[doc = "  @code"]
    #[doc = "  void function_name(GLFWwindow* window, int iconified)"]
    #[doc = "  @endcode"]
    #[doc = "  For more information about the callback parameters, see the"]
    #[doc = "  [function pointer type](@ref GLFWwindowiconifyfun)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @remark @wayland The wl_shell protocol has no concept of iconification,"]
    #[doc = "  this callback will never be called when using this deprecated protocol."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_iconify"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowIconifyCallback(
        window: *mut GLFWwindow,
        callback: GLFWwindowiconifyfun,
    ) -> GLFWwindowiconifyfun;
}
extern "C" {
    #[doc = " @brief Sets the maximize callback for the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the maximization callback of the specified window, which"]
    #[doc = "  is called when the window is maximized or restored."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] callback The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @callback_signature"]
    #[doc = "  @code"]
    #[doc = "  void function_name(GLFWwindow* window, int maximized)"]
    #[doc = "  @endcode"]
    #[doc = "  For more information about the callback parameters, see the"]
    #[doc = "  [function pointer type](@ref GLFWwindowmaximizefun)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_maximize"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowMaximizeCallback(
        window: *mut GLFWwindow,
        callback: GLFWwindowmaximizefun,
    ) -> GLFWwindowmaximizefun;
}
extern "C" {
    #[doc = " @brief Sets the framebuffer resize callback for the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the framebuffer resize callback of the specified window,"]
    #[doc = "  which is called when the framebuffer of the specified window is resized."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] callback The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @callback_signature"]
    #[doc = "  @code"]
    #[doc = "  void function_name(GLFWwindow* window, int width, int height)"]
    #[doc = "  @endcode"]
    #[doc = "  For more information about the callback parameters, see the"]
    #[doc = "  [function pointer type](@ref GLFWframebuffersizefun)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_fbsize"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetFramebufferSizeCallback(
        window: *mut GLFWwindow,
        callback: GLFWframebuffersizefun,
    ) -> GLFWframebuffersizefun;
}
extern "C" {
    #[doc = " @brief Sets the window content scale callback for the specified window."]
    #[doc = ""]
    #[doc = "  This function sets the window content scale callback of the specified window,"]
    #[doc = "  which is called when the content scale of the specified window changes."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] callback The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @callback_signature"]
    #[doc = "  @code"]
    #[doc = "  void function_name(GLFWwindow* window, float xscale, float yscale)"]
    #[doc = "  @endcode"]
    #[doc = "  For more information about the callback parameters, see the"]
    #[doc = "  [function pointer type](@ref GLFWwindowcontentscalefun)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref window_scale"]
    #[doc = "  @sa @ref glfwGetWindowContentScale"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSetWindowContentScaleCallback(
        window: *mut GLFWwindow,
        callback: GLFWwindowcontentscalefun,
    ) -> GLFWwindowcontentscalefun;
}
extern "C" {
    #[doc = " @brief Processes all pending events."]
    #[doc = ""]
    #[doc = "  This function processes only those events that are already in the event"]
    #[doc = "  queue and then returns immediately.  Processing events will cause the window"]
    #[doc = "  and input callbacks associated with those events to be called."]
    #[doc = ""]
    #[doc = "  On some platforms, a window move, resize or menu operation will cause event"]
    #[doc = "  processing to block.  This is due to how event processing is designed on"]
    #[doc = "  those platforms.  You can use the"]
    #[doc = "  [window refresh callback](@ref window_refresh) to redraw the contents of"]
    #[doc = "  your window when necessary during such operations."]
    #[doc = ""]
    #[doc = "  Do not assume that callbacks you set will _only_ be called in response to"]
    #[doc = "  event processing functions like this one.  While it is necessary to poll for"]
    #[doc = "  events, window systems that require GLFW to register callbacks of its own"]
    #[doc = "  can pass events to GLFW in response to many window system function calls."]
    #[doc = "  GLFW will pass those events on to the application callbacks before"]
    #[doc = "  returning."]
    #[doc = ""]
    #[doc = "  Event processing is not required for joystick input to work."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @reentrancy This function must not be called from a callback."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref events"]
    #[doc = "  @sa @ref glfwWaitEvents"]
    #[doc = "  @sa @ref glfwWaitEventsTimeout"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwPollEvents();
}
extern "C" {
    #[doc = " @brief Waits until events are queued and processes them."]
    #[doc = ""]
    #[doc = "  This function puts the calling thread to sleep until at least one event is"]
    #[doc = "  available in the event queue.  Once one or more events are available,"]
    #[doc = "  it behaves exactly like @ref glfwPollEvents, i.e. the events in the queue"]
    #[doc = "  are processed and the function then returns immediately.  Processing events"]
    #[doc = "  will cause the window and input callbacks associated with those events to be"]
    #[doc = "  called."]
    #[doc = ""]
    #[doc = "  Since not all events are associated with callbacks, this function may return"]
    #[doc = "  without a callback having been called even if you are monitoring all"]
    #[doc = "  callbacks."]
    #[doc = ""]
    #[doc = "  On some platforms, a window move, resize or menu operation will cause event"]
    #[doc = "  processing to block.  This is due to how event processing is designed on"]
    #[doc = "  those platforms.  You can use the"]
    #[doc = "  [window refresh callback](@ref window_refresh) to redraw the contents of"]
    #[doc = "  your window when necessary during such operations."]
    #[doc = ""]
    #[doc = "  Do not assume that callbacks you set will _only_ be called in response to"]
    #[doc = "  event processing functions like this one.  While it is necessary to poll for"]
    #[doc = "  events, window systems that require GLFW to register callbacks of its own"]
    #[doc = "  can pass events to GLFW in response to many window system function calls."]
    #[doc = "  GLFW will pass those events on to the application callbacks before"]
    #[doc = "  returning."]
    #[doc = ""]
    #[doc = "  Event processing is not required for joystick input to work."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @reentrancy This function must not be called from a callback."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref events"]
    #[doc = "  @sa @ref glfwPollEvents"]
    #[doc = "  @sa @ref glfwWaitEventsTimeout"]
    #[doc = ""]
    #[doc = "  @since Added in version 2.5."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwWaitEvents();
}
extern "C" {
    #[doc = " @brief Waits with timeout until events are queued and processes them."]
    #[doc = ""]
    #[doc = "  This function puts the calling thread to sleep until at least one event is"]
    #[doc = "  available in the event queue, or until the specified timeout is reached.  If"]
    #[doc = "  one or more events are available, it behaves exactly like @ref"]
    #[doc = "  glfwPollEvents, i.e. the events in the queue are processed and the function"]
    #[doc = "  then returns immediately.  Processing events will cause the window and input"]
    #[doc = "  callbacks associated with those events to be called."]
    #[doc = ""]
    #[doc = "  The timeout value must be a positive finite number."]
    #[doc = ""]
    #[doc = "  Since not all events are associated with callbacks, this function may return"]
    #[doc = "  without a callback having been called even if you are monitoring all"]
    #[doc = "  callbacks."]
    #[doc = ""]
    #[doc = "  On some platforms, a window move, resize or menu operation will cause event"]
    #[doc = "  processing to block.  This is due to how event processing is designed on"]
    #[doc = "  those platforms.  You can use the"]
    #[doc = "  [window refresh callback](@ref window_refresh) to redraw the contents of"]
    #[doc = "  your window when necessary during such operations."]
    #[doc = ""]
    #[doc = "  Do not assume that callbacks you set will _only_ be called in response to"]
    #[doc = "  event processing functions like this one.  While it is necessary to poll for"]
    #[doc = "  events, window systems that require GLFW to register callbacks of its own"]
    #[doc = "  can pass events to GLFW in response to many window system function calls."]
    #[doc = "  GLFW will pass those events on to the application callbacks before"]
    #[doc = "  returning."]
    #[doc = ""]
    #[doc = "  Event processing is not required for joystick input to work."]
    #[doc = ""]
    #[doc = "  @param[in] timeout The maximum amount of time, in seconds, to wait."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_VALUE and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @reentrancy This function must not be called from a callback."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref events"]
    #[doc = "  @sa @ref glfwPollEvents"]
    #[doc = "  @sa @ref glfwWaitEvents"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwWaitEventsTimeout(timeout: f64);
}
extern "C" {
    #[doc = " @brief Posts an empty event to the event queue."]
    #[doc = ""]
    #[doc = "  This function posts an empty event from the current thread to the event"]
    #[doc = "  queue, causing @ref glfwWaitEvents or @ref glfwWaitEventsTimeout to return."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref events"]
    #[doc = "  @sa @ref glfwWaitEvents"]
    #[doc = "  @sa @ref glfwWaitEventsTimeout"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.1."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwPostEmptyEvent();
}
extern "C" {
    #[doc = " @brief Returns the value of an input option for the specified window."]
    #[doc = ""]
    #[doc = "  This function returns the value of an input option for the specified window."]
    #[doc = "  The mode must be one of @ref GLFW_CURSOR, @ref GLFW_STICKY_KEYS,"]
    #[doc = "  @ref GLFW_STICKY_MOUSE_BUTTONS, @ref GLFW_LOCK_KEY_MODS or"]
    #[doc = "  @ref GLFW_RAW_MOUSE_MOTION."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to query."]
    #[doc = "  @param[in] mode One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS`,"]
    #[doc = "  `GLFW_STICKY_MOUSE_BUTTONS`, `GLFW_LOCK_KEY_MODS` or"]
    #[doc = "  `GLFW_RAW_MOUSE_MOTION`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_INVALID_ENUM."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref glfwSetInputMode"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetInputMode(
        window: *mut GLFWwindow,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Sets an input option for the specified window."]
    #[doc = ""]
    #[doc = "  This function sets an input mode option for the specified window.  The mode"]
    #[doc = "  must be one of @ref GLFW_CURSOR, @ref GLFW_STICKY_KEYS,"]
    #[doc = "  @ref GLFW_STICKY_MOUSE_BUTTONS, @ref GLFW_LOCK_KEY_MODS or"]
    #[doc = "  @ref GLFW_RAW_MOUSE_MOTION."]
    #[doc = ""]
    #[doc = "  If the mode is `GLFW_CURSOR`, the value must be one of the following cursor"]
    #[doc = "  modes:"]
    #[doc = "  - `GLFW_CURSOR_NORMAL` makes the cursor visible and behaving normally."]
    #[doc = "  - `GLFW_CURSOR_HIDDEN` makes the cursor invisible when it is over the"]
    #[doc = "    content area of the window but does not restrict the cursor from leaving."]
    #[doc = "  - `GLFW_CURSOR_DISABLED` hides and grabs the cursor, providing virtual"]
    #[doc = "    and unlimited cursor movement.  This is useful for implementing for"]
    #[doc = "    example 3D camera controls."]
    #[doc = ""]
    #[doc = "  If the mode is `GLFW_STICKY_KEYS`, the value must be either `GLFW_TRUE` to"]
    #[doc = "  enable sticky keys, or `GLFW_FALSE` to disable it.  If sticky keys are"]
    #[doc = "  enabled, a key press will ensure that @ref glfwGetKey returns `GLFW_PRESS`"]
    #[doc = "  the next time it is called even if the key had been released before the"]
    #[doc = "  call.  This is useful when you are only interested in whether keys have been"]
    #[doc = "  pressed but not when or in which order."]
    #[doc = ""]
    #[doc = "  If the mode is `GLFW_STICKY_MOUSE_BUTTONS`, the value must be either"]
    #[doc = "  `GLFW_TRUE` to enable sticky mouse buttons, or `GLFW_FALSE` to disable it."]
    #[doc = "  If sticky mouse buttons are enabled, a mouse button press will ensure that"]
    #[doc = "  @ref glfwGetMouseButton returns `GLFW_PRESS` the next time it is called even"]
    #[doc = "  if the mouse button had been released before the call.  This is useful when"]
    #[doc = "  you are only interested in whether mouse buttons have been pressed but not"]
    #[doc = "  when or in which order."]
    #[doc = ""]
    #[doc = "  If the mode is `GLFW_LOCK_KEY_MODS`, the value must be either `GLFW_TRUE` to"]
    #[doc = "  enable lock key modifier bits, or `GLFW_FALSE` to disable them.  If enabled,"]
    #[doc = "  callbacks that receive modifier bits will also have the @ref"]
    #[doc = "  GLFW_MOD_CAPS_LOCK bit set when the event was generated with Caps Lock on,"]
    #[doc = "  and the @ref GLFW_MOD_NUM_LOCK bit when Num Lock was on."]
    #[doc = ""]
    #[doc = "  If the mode is `GLFW_RAW_MOUSE_MOTION`, the value must be either `GLFW_TRUE`"]
    #[doc = "  to enable raw (unscaled and unaccelerated) mouse motion when the cursor is"]
    #[doc = "  disabled, or `GLFW_FALSE` to disable it.  If raw motion is not supported,"]
    #[doc = "  attempting to set this will emit @ref GLFW_PLATFORM_ERROR.  Call @ref"]
    #[doc = "  glfwRawMouseMotionSupported to check for support."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose input mode to set."]
    #[doc = "  @param[in] mode One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS`,"]
    #[doc = "  `GLFW_STICKY_MOUSE_BUTTONS`, `GLFW_LOCK_KEY_MODS` or"]
    #[doc = "  `GLFW_RAW_MOUSE_MOTION`."]
    #[doc = "  @param[in] value The new value of the specified input mode."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref glfwGetInputMode"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwEnable` and `glfwDisable`."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetInputMode(
        window: *mut GLFWwindow,
        mode: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Returns whether raw mouse motion is supported."]
    #[doc = ""]
    #[doc = "  This function returns whether raw mouse motion is supported on the current"]
    #[doc = "  system.  This status does not change after GLFW has been initialized so you"]
    #[doc = "  only need to check this once.  If you attempt to enable raw motion on"]
    #[doc = "  a system that does not support it, @ref GLFW_PLATFORM_ERROR will be emitted."]
    #[doc = ""]
    #[doc = "  Raw mouse motion is closer to the actual motion of the mouse across"]
    #[doc = "  a surface.  It is not affected by the scaling and acceleration applied to"]
    #[doc = "  the motion of the desktop cursor.  That processing is suitable for a cursor"]
    #[doc = "  while raw motion is better for controlling for example a 3D camera.  Because"]
    #[doc = "  of this, raw mouse motion is only provided when the cursor is disabled."]
    #[doc = ""]
    #[doc = "  @return `GLFW_TRUE` if raw mouse motion is supported on the current machine,"]
    #[doc = "  or `GLFW_FALSE` otherwise."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref raw_mouse_motion"]
    #[doc = "  @sa @ref glfwSetInputMode"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwRawMouseMotionSupported() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Returns the layout-specific name of the specified printable key."]
    #[doc = ""]
    #[doc = "  This function returns the name of the specified printable key, encoded as"]
    #[doc = "  UTF-8.  This is typically the character that key would produce without any"]
    #[doc = "  modifier keys, intended for displaying key bindings to the user.  For dead"]
    #[doc = "  keys, it is typically the diacritic it would add to a character."]
    #[doc = ""]
    #[doc = "  __Do not use this function__ for [text input](@ref input_char).  You will"]
    #[doc = "  break text input for many languages even if it happens to work for yours."]
    #[doc = ""]
    #[doc = "  If the key is `GLFW_KEY_UNKNOWN`, the scancode is used to identify the key,"]
    #[doc = "  otherwise the scancode is ignored.  If you specify a non-printable key, or"]
    #[doc = "  `GLFW_KEY_UNKNOWN` and a scancode that maps to a non-printable key, this"]
    #[doc = "  function returns `NULL` but does not emit an error."]
    #[doc = ""]
    #[doc = "  This behavior allows you to always pass in the arguments in the"]
    #[doc = "  [key callback](@ref input_key) without modification."]
    #[doc = ""]
    #[doc = "  The printable keys are:"]
    #[doc = "  - `GLFW_KEY_APOSTROPHE`"]
    #[doc = "  - `GLFW_KEY_COMMA`"]
    #[doc = "  - `GLFW_KEY_MINUS`"]
    #[doc = "  - `GLFW_KEY_PERIOD`"]
    #[doc = "  - `GLFW_KEY_SLASH`"]
    #[doc = "  - `GLFW_KEY_SEMICOLON`"]
    #[doc = "  - `GLFW_KEY_EQUAL`"]
    #[doc = "  - `GLFW_KEY_LEFT_BRACKET`"]
    #[doc = "  - `GLFW_KEY_RIGHT_BRACKET`"]
    #[doc = "  - `GLFW_KEY_BACKSLASH`"]
    #[doc = "  - `GLFW_KEY_WORLD_1`"]
    #[doc = "  - `GLFW_KEY_WORLD_2`"]
    #[doc = "  - `GLFW_KEY_0` to `GLFW_KEY_9`"]
    #[doc = "  - `GLFW_KEY_A` to `GLFW_KEY_Z`"]
    #[doc = "  - `GLFW_KEY_KP_0` to `GLFW_KEY_KP_9`"]
    #[doc = "  - `GLFW_KEY_KP_DECIMAL`"]
    #[doc = "  - `GLFW_KEY_KP_DIVIDE`"]
    #[doc = "  - `GLFW_KEY_KP_MULTIPLY`"]
    #[doc = "  - `GLFW_KEY_KP_SUBTRACT`"]
    #[doc = "  - `GLFW_KEY_KP_ADD`"]
    #[doc = "  - `GLFW_KEY_KP_EQUAL`"]
    #[doc = ""]
    #[doc = "  Names for printable keys depend on keyboard layout, while names for"]
    #[doc = "  non-printable keys are the same across layouts but depend on the application"]
    #[doc = "  language and should be localized along with other user interface text."]
    #[doc = ""]
    #[doc = "  @param[in] key The key to query, or `GLFW_KEY_UNKNOWN`."]
    #[doc = "  @param[in] scancode The scancode of the key to query."]
    #[doc = "  @return The UTF-8 encoded, layout-specific name of the key, or `NULL`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark The contents of the returned string may change when a keyboard"]
    #[doc = "  layout change event is received."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned string is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is valid until the library is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref input_key_name"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetKeyName(
        key: ::std::os::raw::c_int,
        scancode: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns the platform-specific scancode of the specified key."]
    #[doc = ""]
    #[doc = "  This function returns the platform-specific scancode of the specified key."]
    #[doc = ""]
    #[doc = "  If the key is `GLFW_KEY_UNKNOWN` or does not exist on the keyboard this"]
    #[doc = "  method will return `-1`."]
    #[doc = ""]
    #[doc = "  @param[in] key Any [named key](@ref keys)."]
    #[doc = "  @return The platform-specific scancode for the key, or `-1` if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref input_key"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetKeyScancode(key: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Returns the last reported state of a keyboard key for the specified"]
    #[doc = "  window."]
    #[doc = ""]
    #[doc = "  This function returns the last state reported for the specified key to the"]
    #[doc = "  specified window.  The returned state is one of `GLFW_PRESS` or"]
    #[doc = "  `GLFW_RELEASE`.  The higher-level action `GLFW_REPEAT` is only reported to"]
    #[doc = "  the key callback."]
    #[doc = ""]
    #[doc = "  If the @ref GLFW_STICKY_KEYS input mode is enabled, this function returns"]
    #[doc = "  `GLFW_PRESS` the first time you call it for a key that was pressed, even if"]
    #[doc = "  that key has already been released."]
    #[doc = ""]
    #[doc = "  The key functions deal with physical keys, with [key tokens](@ref keys)"]
    #[doc = "  named after their use on the standard US keyboard layout.  If you want to"]
    #[doc = "  input text, use the Unicode character callback instead."]
    #[doc = ""]
    #[doc = "  The [modifier key bit masks](@ref mods) are not key tokens and cannot be"]
    #[doc = "  used with this function."]
    #[doc = ""]
    #[doc = "  __Do not use this function__ to implement [text input](@ref input_char)."]
    #[doc = ""]
    #[doc = "  @param[in] window The desired window."]
    #[doc = "  @param[in] key The desired [keyboard key](@ref keys).  `GLFW_KEY_UNKNOWN` is"]
    #[doc = "  not a valid key for this function."]
    #[doc = "  @return One of `GLFW_PRESS` or `GLFW_RELEASE`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_INVALID_ENUM."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref input_key"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = "  @glfw3 Added window handle parameter."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetKey(window: *mut GLFWwindow, key: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Returns the last reported state of a mouse button for the specified"]
    #[doc = "  window."]
    #[doc = ""]
    #[doc = "  This function returns the last state reported for the specified mouse button"]
    #[doc = "  to the specified window.  The returned state is one of `GLFW_PRESS` or"]
    #[doc = "  `GLFW_RELEASE`."]
    #[doc = ""]
    #[doc = "  If the @ref GLFW_STICKY_MOUSE_BUTTONS input mode is enabled, this function"]
    #[doc = "  returns `GLFW_PRESS` the first time you call it for a mouse button that was"]
    #[doc = "  pressed, even if that mouse button has already been released."]
    #[doc = ""]
    #[doc = "  @param[in] window The desired window."]
    #[doc = "  @param[in] button The desired [mouse button](@ref buttons)."]
    #[doc = "  @return One of `GLFW_PRESS` or `GLFW_RELEASE`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_INVALID_ENUM."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref input_mouse_button"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = "  @glfw3 Added window handle parameter."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetMouseButton(
        window: *mut GLFWwindow,
        button: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieves the position of the cursor relative to the content area of"]
    #[doc = "  the window."]
    #[doc = ""]
    #[doc = "  This function returns the position of the cursor, in screen coordinates,"]
    #[doc = "  relative to the upper-left corner of the content area of the specified"]
    #[doc = "  window."]
    #[doc = ""]
    #[doc = "  If the cursor is disabled (with `GLFW_CURSOR_DISABLED`) then the cursor"]
    #[doc = "  position is unbounded and limited only by the minimum and maximum values of"]
    #[doc = "  a `double`."]
    #[doc = ""]
    #[doc = "  The coordinate can be converted to their integer equivalents with the"]
    #[doc = "  `floor` function.  Casting directly to an integer type works for positive"]
    #[doc = "  coordinates, but fails for negative ones."]
    #[doc = ""]
    #[doc = "  Any or all of the position arguments may be `NULL`.  If an error occurs, all"]
    #[doc = "  non-`NULL` position arguments will be set to zero."]
    #[doc = ""]
    #[doc = "  @param[in] window The desired window."]
    #[doc = "  @param[out] xpos Where to store the cursor x-coordinate, relative to the"]
    #[doc = "  left edge of the content area, or `NULL`."]
    #[doc = "  @param[out] ypos Where to store the cursor y-coordinate, relative to the to"]
    #[doc = "  top edge of the content area, or `NULL`."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref cursor_pos"]
    #[doc = "  @sa @ref glfwSetCursorPos"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwGetMousePos`."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetCursorPos(window: *mut GLFWwindow, xpos: *mut f64, ypos: *mut f64);
}
extern "C" {
    #[doc = " @brief Sets the position of the cursor, relative to the content area of the"]
    #[doc = "  window."]
    #[doc = ""]
    #[doc = "  This function sets the position, in screen coordinates, of the cursor"]
    #[doc = "  relative to the upper-left corner of the content area of the specified"]
    #[doc = "  window.  The window must have input focus.  If the window does not have"]
    #[doc = "  input focus when this function is called, it fails silently."]
    #[doc = ""]
    #[doc = "  __Do not use this function__ to implement things like camera controls.  GLFW"]
    #[doc = "  already provides the `GLFW_CURSOR_DISABLED` cursor mode that hides the"]
    #[doc = "  cursor, transparently re-centers it and provides unconstrained cursor"]
    #[doc = "  motion.  See @ref glfwSetInputMode for more information."]
    #[doc = ""]
    #[doc = "  If the cursor mode is `GLFW_CURSOR_DISABLED` then the cursor position is"]
    #[doc = "  unconstrained and limited only by the minimum and maximum values of"]
    #[doc = "  a `double`."]
    #[doc = ""]
    #[doc = "  @param[in] window The desired window."]
    #[doc = "  @param[in] xpos The desired x-coordinate, relative to the left edge of the"]
    #[doc = "  content area."]
    #[doc = "  @param[in] ypos The desired y-coordinate, relative to the top edge of the"]
    #[doc = "  content area."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark @wayland This function will only work when the cursor mode is"]
    #[doc = "  `GLFW_CURSOR_DISABLED`, otherwise it will do nothing."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref cursor_pos"]
    #[doc = "  @sa @ref glfwGetCursorPos"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwSetMousePos`."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetCursorPos(window: *mut GLFWwindow, xpos: f64, ypos: f64);
}
extern "C" {
    #[doc = " @brief Creates a custom cursor."]
    #[doc = ""]
    #[doc = "  Creates a new custom cursor image that can be set for a window with @ref"]
    #[doc = "  glfwSetCursor.  The cursor can be destroyed with @ref glfwDestroyCursor."]
    #[doc = "  Any remaining cursors are destroyed by @ref glfwTerminate."]
    #[doc = ""]
    #[doc = "  The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight"]
    #[doc = "  bits per channel with the red channel first.  They are arranged canonically"]
    #[doc = "  as packed sequential rows, starting from the top-left corner."]
    #[doc = ""]
    #[doc = "  The cursor hotspot is specified in pixels, relative to the upper-left corner"]
    #[doc = "  of the cursor image.  Like all other coordinate systems in GLFW, the X-axis"]
    #[doc = "  points to the right and the Y-axis points down."]
    #[doc = ""]
    #[doc = "  @param[in] image The desired cursor image."]
    #[doc = "  @param[in] xhot The desired x-coordinate, in pixels, of the cursor hotspot."]
    #[doc = "  @param[in] yhot The desired y-coordinate, in pixels, of the cursor hotspot."]
    #[doc = "  @return The handle of the created cursor, or `NULL` if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The specified image data is copied before this function"]
    #[doc = "  returns."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref cursor_object"]
    #[doc = "  @sa @ref glfwDestroyCursor"]
    #[doc = "  @sa @ref glfwCreateStandardCursor"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.1."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwCreateCursor(
        image: *const GLFWimage,
        xhot: ::std::os::raw::c_int,
        yhot: ::std::os::raw::c_int,
    ) -> *mut GLFWcursor;
}
extern "C" {
    #[doc = " @brief Creates a cursor with a standard shape."]
    #[doc = ""]
    #[doc = "  Returns a cursor with a [standard shape](@ref shapes), that can be set for"]
    #[doc = "  a window with @ref glfwSetCursor."]
    #[doc = ""]
    #[doc = "  @param[in] shape One of the [standard shapes](@ref shapes)."]
    #[doc = "  @return A new cursor ready to use or `NULL` if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref cursor_object"]
    #[doc = "  @sa @ref glfwCreateCursor"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.1."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwCreateStandardCursor(shape: ::std::os::raw::c_int) -> *mut GLFWcursor;
}
extern "C" {
    #[doc = " @brief Destroys a cursor."]
    #[doc = ""]
    #[doc = "  This function destroys a cursor previously created with @ref"]
    #[doc = "  glfwCreateCursor.  Any remaining cursors will be destroyed by @ref"]
    #[doc = "  glfwTerminate."]
    #[doc = ""]
    #[doc = "  If the specified cursor is current for any window, that window will be"]
    #[doc = "  reverted to the default cursor.  This does not affect the cursor mode."]
    #[doc = ""]
    #[doc = "  @param[in] cursor The cursor object to destroy."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @reentrancy This function must not be called from a callback."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref cursor_object"]
    #[doc = "  @sa @ref glfwCreateCursor"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.1."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwDestroyCursor(cursor: *mut GLFWcursor);
}
extern "C" {
    #[doc = " @brief Sets the cursor for the window."]
    #[doc = ""]
    #[doc = "  This function sets the cursor image to be used when the cursor is over the"]
    #[doc = "  content area of the specified window.  The set cursor will only be visible"]
    #[doc = "  when the [cursor mode](@ref cursor_mode) of the window is"]
    #[doc = "  `GLFW_CURSOR_NORMAL`."]
    #[doc = ""]
    #[doc = "  On some platforms, the set cursor may not be visible unless the window also"]
    #[doc = "  has input focus."]
    #[doc = ""]
    #[doc = "  @param[in] window The window to set the cursor for."]
    #[doc = "  @param[in] cursor The cursor to set, or `NULL` to switch back to the default"]
    #[doc = "  arrow cursor."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref cursor_object"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.1."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetCursor(window: *mut GLFWwindow, cursor: *mut GLFWcursor);
}
extern "C" {
    #[doc = " @brief Sets the key callback."]
    #[doc = ""]
    #[doc = "  This function sets the key callback of the specified window, which is called"]
    #[doc = "  when a key is pressed, repeated or released."]
    #[doc = ""]
    #[doc = "  The key functions deal with physical keys, with layout independent"]
    #[doc = "  [key tokens](@ref keys) named after their values in the standard US keyboard"]
    #[doc = "  layout.  If you want to input text, use the"]
    #[doc = "  [character callback](@ref glfwSetCharCallback) instead."]
    #[doc = ""]
    #[doc = "  When a window loses input focus, it will generate synthetic key release"]
    #[doc = "  events for all pressed keys.  You can tell these events from user-generated"]
    #[doc = "  events by the fact that the synthetic ones are generated after the focus"]
    #[doc = "  loss event has been processed, i.e. after the"]
    #[doc = "  [window focus callback](@ref glfwSetWindowFocusCallback) has been called."]
    #[doc = ""]
    #[doc = "  The scancode of a key is specific to that platform or sometimes even to that"]
    #[doc = "  machine.  Scancodes are intended to allow users to bind keys that don't have"]
    #[doc = "  a GLFW key token.  Such keys have `key` set to `GLFW_KEY_UNKNOWN`, their"]
    #[doc = "  state is not saved and so it cannot be queried with @ref glfwGetKey."]
    #[doc = ""]
    #[doc = "  Sometimes GLFW needs to generate synthetic key events, in which case the"]
    #[doc = "  scancode may be zero."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] callback The new key callback, or `NULL` to remove the currently"]
    #[doc = "  set callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @callback_signature"]
    #[doc = "  @code"]
    #[doc = "  void function_name(GLFWwindow* window, int key, int scancode, int action, int mods)"]
    #[doc = "  @endcode"]
    #[doc = "  For more information about the callback parameters, see the"]
    #[doc = "  [function pointer type](@ref GLFWkeyfun)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref input_key"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = "  @glfw3 Added window handle parameter and return value."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetKeyCallback(window: *mut GLFWwindow, callback: GLFWkeyfun) -> GLFWkeyfun;
}
extern "C" {
    #[doc = " @brief Sets the Unicode character callback."]
    #[doc = ""]
    #[doc = "  This function sets the character callback of the specified window, which is"]
    #[doc = "  called when a Unicode character is input."]
    #[doc = ""]
    #[doc = "  The character callback is intended for Unicode text input.  As it deals with"]
    #[doc = "  characters, it is keyboard layout dependent, whereas the"]
    #[doc = "  [key callback](@ref glfwSetKeyCallback) is not.  Characters do not map 1:1"]
    #[doc = "  to physical keys, as a key may produce zero, one or more characters.  If you"]
    #[doc = "  want to know whether a specific physical key was pressed or released, see"]
    #[doc = "  the key callback instead."]
    #[doc = ""]
    #[doc = "  The character callback behaves as system text input normally does and will"]
    #[doc = "  not be called if modifier keys are held down that would prevent normal text"]
    #[doc = "  input on that platform, for example a Super (Command) key on macOS or Alt key"]
    #[doc = "  on Windows."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] callback The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @callback_signature"]
    #[doc = "  @code"]
    #[doc = "  void function_name(GLFWwindow* window, unsigned int codepoint)"]
    #[doc = "  @endcode"]
    #[doc = "  For more information about the callback parameters, see the"]
    #[doc = "  [function pointer type](@ref GLFWcharfun)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref input_char"]
    #[doc = ""]
    #[doc = "  @since Added in version 2.4."]
    #[doc = "  @glfw3 Added window handle parameter and return value."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetCharCallback(window: *mut GLFWwindow, callback: GLFWcharfun) -> GLFWcharfun;
}
extern "C" {
    #[doc = " @brief Sets the Unicode character with modifiers callback."]
    #[doc = ""]
    #[doc = "  This function sets the character with modifiers callback of the specified"]
    #[doc = "  window, which is called when a Unicode character is input regardless of what"]
    #[doc = "  modifier keys are used."]
    #[doc = ""]
    #[doc = "  The character with modifiers callback is intended for implementing custom"]
    #[doc = "  Unicode character input.  For regular Unicode text input, see the"]
    #[doc = "  [character callback](@ref glfwSetCharCallback).  Like the character"]
    #[doc = "  callback, the character with modifiers callback deals with characters and is"]
    #[doc = "  keyboard layout dependent.  Characters do not map 1:1 to physical keys, as"]
    #[doc = "  a key may produce zero, one or more characters.  If you want to know whether"]
    #[doc = "  a specific physical key was pressed or released, see the"]
    #[doc = "  [key callback](@ref glfwSetKeyCallback) instead."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] callback The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @callback_signature"]
    #[doc = "  @code"]
    #[doc = "  void function_name(GLFWwindow* window, unsigned int codepoint, int mods)"]
    #[doc = "  @endcode"]
    #[doc = "  For more information about the callback parameters, see the"]
    #[doc = "  [function pointer type](@ref GLFWcharmodsfun)."]
    #[doc = ""]
    #[doc = "  @deprecated Scheduled for removal in version 4.0."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref input_char"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.1."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetCharModsCallback(
        window: *mut GLFWwindow,
        callback: GLFWcharmodsfun,
    ) -> GLFWcharmodsfun;
}
extern "C" {
    #[doc = " @brief Sets the mouse button callback."]
    #[doc = ""]
    #[doc = "  This function sets the mouse button callback of the specified window, which"]
    #[doc = "  is called when a mouse button is pressed or released."]
    #[doc = ""]
    #[doc = "  When a window loses input focus, it will generate synthetic mouse button"]
    #[doc = "  release events for all pressed mouse buttons.  You can tell these events"]
    #[doc = "  from user-generated events by the fact that the synthetic ones are generated"]
    #[doc = "  after the focus loss event has been processed, i.e. after the"]
    #[doc = "  [window focus callback](@ref glfwSetWindowFocusCallback) has been called."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] callback The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @callback_signature"]
    #[doc = "  @code"]
    #[doc = "  void function_name(GLFWwindow* window, int button, int action, int mods)"]
    #[doc = "  @endcode"]
    #[doc = "  For more information about the callback parameters, see the"]
    #[doc = "  [function pointer type](@ref GLFWmousebuttonfun)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref input_mouse_button"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = "  @glfw3 Added window handle parameter and return value."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetMouseButtonCallback(
        window: *mut GLFWwindow,
        callback: GLFWmousebuttonfun,
    ) -> GLFWmousebuttonfun;
}
extern "C" {
    #[doc = " @brief Sets the cursor position callback."]
    #[doc = ""]
    #[doc = "  This function sets the cursor position callback of the specified window,"]
    #[doc = "  which is called when the cursor is moved.  The callback is provided with the"]
    #[doc = "  position, in screen coordinates, relative to the upper-left corner of the"]
    #[doc = "  content area of the window."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] callback The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @callback_signature"]
    #[doc = "  @code"]
    #[doc = "  void function_name(GLFWwindow* window, double xpos, double ypos);"]
    #[doc = "  @endcode"]
    #[doc = "  For more information about the callback parameters, see the"]
    #[doc = "  [function pointer type](@ref GLFWcursorposfun)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref cursor_pos"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwSetMousePosCallback`."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetCursorPosCallback(
        window: *mut GLFWwindow,
        callback: GLFWcursorposfun,
    ) -> GLFWcursorposfun;
}
extern "C" {
    #[doc = " @brief Sets the cursor enter/leave callback."]
    #[doc = ""]
    #[doc = "  This function sets the cursor boundary crossing callback of the specified"]
    #[doc = "  window, which is called when the cursor enters or leaves the content area of"]
    #[doc = "  the window."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] callback The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @callback_signature"]
    #[doc = "  @code"]
    #[doc = "  void function_name(GLFWwindow* window, int entered)"]
    #[doc = "  @endcode"]
    #[doc = "  For more information about the callback parameters, see the"]
    #[doc = "  [function pointer type](@ref GLFWcursorenterfun)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref cursor_enter"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetCursorEnterCallback(
        window: *mut GLFWwindow,
        callback: GLFWcursorenterfun,
    ) -> GLFWcursorenterfun;
}
extern "C" {
    #[doc = " @brief Sets the scroll callback."]
    #[doc = ""]
    #[doc = "  This function sets the scroll callback of the specified window, which is"]
    #[doc = "  called when a scrolling device is used, such as a mouse wheel or scrolling"]
    #[doc = "  area of a touchpad."]
    #[doc = ""]
    #[doc = "  The scroll callback receives all scrolling input, like that from a mouse"]
    #[doc = "  wheel or a touchpad scrolling area."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] callback The new scroll callback, or `NULL` to remove the"]
    #[doc = "  currently set callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @callback_signature"]
    #[doc = "  @code"]
    #[doc = "  void function_name(GLFWwindow* window, double xoffset, double yoffset)"]
    #[doc = "  @endcode"]
    #[doc = "  For more information about the callback parameters, see the"]
    #[doc = "  [function pointer type](@ref GLFWscrollfun)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref scrolling"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwSetMouseWheelCallback`."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetScrollCallback(window: *mut GLFWwindow, callback: GLFWscrollfun)
        -> GLFWscrollfun;
}
extern "C" {
    #[doc = " @brief Sets the path drop callback."]
    #[doc = ""]
    #[doc = "  This function sets the path drop callback of the specified window, which is"]
    #[doc = "  called when one or more dragged paths are dropped on the window."]
    #[doc = ""]
    #[doc = "  Because the path array and its strings may have been generated specifically"]
    #[doc = "  for that event, they are not guaranteed to be valid after the callback has"]
    #[doc = "  returned.  If you wish to use them after the callback returns, you need to"]
    #[doc = "  make a deep copy."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose callback to set."]
    #[doc = "  @param[in] callback The new file drop callback, or `NULL` to remove the"]
    #[doc = "  currently set callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @callback_signature"]
    #[doc = "  @code"]
    #[doc = "  void function_name(GLFWwindow* window, int path_count, const char* paths[])"]
    #[doc = "  @endcode"]
    #[doc = "  For more information about the callback parameters, see the"]
    #[doc = "  [function pointer type](@ref GLFWdropfun)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @remark @wayland File drop is currently unimplemented."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref path_drop"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.1."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetDropCallback(window: *mut GLFWwindow, callback: GLFWdropfun) -> GLFWdropfun;
}
extern "C" {
    #[doc = " @brief Returns whether the specified joystick is present."]
    #[doc = ""]
    #[doc = "  This function returns whether the specified joystick is present."]
    #[doc = ""]
    #[doc = "  There is no need to call this function before other functions that accept"]
    #[doc = "  a joystick ID, as they all check for presence before performing any other"]
    #[doc = "  work."]
    #[doc = ""]
    #[doc = "  @param[in] jid The [joystick](@ref joysticks) to query."]
    #[doc = "  @return `GLFW_TRUE` if the joystick is present, or `GLFW_FALSE` otherwise."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref joystick"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwGetJoystickParam`."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwJoystickPresent(jid: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Returns the values of all axes of the specified joystick."]
    #[doc = ""]
    #[doc = "  This function returns the values of all axes of the specified joystick."]
    #[doc = "  Each element in the array is a value between -1.0 and 1.0."]
    #[doc = ""]
    #[doc = "  If the specified joystick is not present this function will return `NULL`"]
    #[doc = "  but will not generate an error.  This can be used instead of first calling"]
    #[doc = "  @ref glfwJoystickPresent."]
    #[doc = ""]
    #[doc = "  @param[in] jid The [joystick](@ref joysticks) to query."]
    #[doc = "  @param[out] count Where to store the number of axis values in the returned"]
    #[doc = "  array.  This is set to zero if the joystick is not present or an error"]
    #[doc = "  occurred."]
    #[doc = "  @return An array of axis values, or `NULL` if the joystick is not present or"]
    #[doc = "  an [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned array is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is valid until the specified joystick is"]
    #[doc = "  disconnected or the library is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref joystick_axis"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0.  Replaces `glfwGetJoystickPos`."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetJoystickAxes(
        jid: ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> *const f32;
}
extern "C" {
    #[doc = " @brief Returns the state of all buttons of the specified joystick."]
    #[doc = ""]
    #[doc = "  This function returns the state of all buttons of the specified joystick."]
    #[doc = "  Each element in the array is either `GLFW_PRESS` or `GLFW_RELEASE`."]
    #[doc = ""]
    #[doc = "  For backward compatibility with earlier versions that did not have @ref"]
    #[doc = "  glfwGetJoystickHats, the button array also includes all hats, each"]
    #[doc = "  represented as four buttons.  The hats are in the same order as returned by"]
    #[doc = "  __glfwGetJoystickHats__ and are in the order _up_, _right_, _down_ and"]
    #[doc = "  _left_.  To disable these extra buttons, set the @ref"]
    #[doc = "  GLFW_JOYSTICK_HAT_BUTTONS init hint before initialization."]
    #[doc = ""]
    #[doc = "  If the specified joystick is not present this function will return `NULL`"]
    #[doc = "  but will not generate an error.  This can be used instead of first calling"]
    #[doc = "  @ref glfwJoystickPresent."]
    #[doc = ""]
    #[doc = "  @param[in] jid The [joystick](@ref joysticks) to query."]
    #[doc = "  @param[out] count Where to store the number of button states in the returned"]
    #[doc = "  array.  This is set to zero if the joystick is not present or an error"]
    #[doc = "  occurred."]
    #[doc = "  @return An array of button states, or `NULL` if the joystick is not present"]
    #[doc = "  or an [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned array is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is valid until the specified joystick is"]
    #[doc = "  disconnected or the library is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref joystick_button"]
    #[doc = ""]
    #[doc = "  @since Added in version 2.2."]
    #[doc = "  @glfw3 Changed to return a dynamic array."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetJoystickButtons(
        jid: ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " @brief Returns the state of all hats of the specified joystick."]
    #[doc = ""]
    #[doc = "  This function returns the state of all hats of the specified joystick."]
    #[doc = "  Each element in the array is one of the following values:"]
    #[doc = ""]
    #[doc = "  Name                  | Value"]
    #[doc = "  ----                  | -----"]
    #[doc = "  `GLFW_HAT_CENTERED`   | 0"]
    #[doc = "  `GLFW_HAT_UP`         | 1"]
    #[doc = "  `GLFW_HAT_RIGHT`      | 2"]
    #[doc = "  `GLFW_HAT_DOWN`       | 4"]
    #[doc = "  `GLFW_HAT_LEFT`       | 8"]
    #[doc = "  `GLFW_HAT_RIGHT_UP`   | `GLFW_HAT_RIGHT` \\| `GLFW_HAT_UP`"]
    #[doc = "  `GLFW_HAT_RIGHT_DOWN` | `GLFW_HAT_RIGHT` \\| `GLFW_HAT_DOWN`"]
    #[doc = "  `GLFW_HAT_LEFT_UP`    | `GLFW_HAT_LEFT` \\| `GLFW_HAT_UP`"]
    #[doc = "  `GLFW_HAT_LEFT_DOWN`  | `GLFW_HAT_LEFT` \\| `GLFW_HAT_DOWN`"]
    #[doc = ""]
    #[doc = "  The diagonal directions are bitwise combinations of the primary (up, right,"]
    #[doc = "  down and left) directions and you can test for these individually by ANDing"]
    #[doc = "  it with the corresponding direction."]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  if (hats[2] & GLFW_HAT_RIGHT)"]
    #[doc = "  {"]
    #[doc = "      // State of hat 2 could be right-up, right or right-down"]
    #[doc = "  }"]
    #[doc = "  @endcode"]
    #[doc = ""]
    #[doc = "  If the specified joystick is not present this function will return `NULL`"]
    #[doc = "  but will not generate an error.  This can be used instead of first calling"]
    #[doc = "  @ref glfwJoystickPresent."]
    #[doc = ""]
    #[doc = "  @param[in] jid The [joystick](@ref joysticks) to query."]
    #[doc = "  @param[out] count Where to store the number of hat states in the returned"]
    #[doc = "  array.  This is set to zero if the joystick is not present or an error"]
    #[doc = "  occurred."]
    #[doc = "  @return An array of hat states, or `NULL` if the joystick is not present"]
    #[doc = "  or an [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned array is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is valid until the specified joystick is"]
    #[doc = "  disconnected, this function is called again for that joystick or the library"]
    #[doc = "  is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref joystick_hat"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetJoystickHats(
        jid: ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " @brief Returns the name of the specified joystick."]
    #[doc = ""]
    #[doc = "  This function returns the name, encoded as UTF-8, of the specified joystick."]
    #[doc = "  The returned string is allocated and freed by GLFW.  You should not free it"]
    #[doc = "  yourself."]
    #[doc = ""]
    #[doc = "  If the specified joystick is not present this function will return `NULL`"]
    #[doc = "  but will not generate an error.  This can be used instead of first calling"]
    #[doc = "  @ref glfwJoystickPresent."]
    #[doc = ""]
    #[doc = "  @param[in] jid The [joystick](@ref joysticks) to query."]
    #[doc = "  @return The UTF-8 encoded name of the joystick, or `NULL` if the joystick"]
    #[doc = "  is not present or an [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned string is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is valid until the specified joystick is"]
    #[doc = "  disconnected or the library is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref joystick_name"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetJoystickName(jid: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns the SDL compatible GUID of the specified joystick."]
    #[doc = ""]
    #[doc = "  This function returns the SDL compatible GUID, as a UTF-8 encoded"]
    #[doc = "  hexadecimal string, of the specified joystick.  The returned string is"]
    #[doc = "  allocated and freed by GLFW.  You should not free it yourself."]
    #[doc = ""]
    #[doc = "  The GUID is what connects a joystick to a gamepad mapping.  A connected"]
    #[doc = "  joystick will always have a GUID even if there is no gamepad mapping"]
    #[doc = "  assigned to it."]
    #[doc = ""]
    #[doc = "  If the specified joystick is not present this function will return `NULL`"]
    #[doc = "  but will not generate an error.  This can be used instead of first calling"]
    #[doc = "  @ref glfwJoystickPresent."]
    #[doc = ""]
    #[doc = "  The GUID uses the format introduced in SDL 2.0.5.  This GUID tries to"]
    #[doc = "  uniquely identify the make and model of a joystick but does not identify"]
    #[doc = "  a specific unit, e.g. all wired Xbox 360 controllers will have the same"]
    #[doc = "  GUID on that platform.  The GUID for a unit may vary between platforms"]
    #[doc = "  depending on what hardware information the platform specific APIs provide."]
    #[doc = ""]
    #[doc = "  @param[in] jid The [joystick](@ref joysticks) to query."]
    #[doc = "  @return The UTF-8 encoded GUID of the joystick, or `NULL` if the joystick"]
    #[doc = "  is not present or an [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_INVALID_ENUM and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned string is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is valid until the specified joystick is"]
    #[doc = "  disconnected or the library is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref gamepad"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetJoystickGUID(jid: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Sets the user pointer of the specified joystick."]
    #[doc = ""]
    #[doc = "  This function sets the user-defined pointer of the specified joystick.  The"]
    #[doc = "  current value is retained until the joystick is disconnected.  The initial"]
    #[doc = "  value is `NULL`."]
    #[doc = ""]
    #[doc = "  This function may be called from the joystick callback, even for a joystick"]
    #[doc = "  that is being disconnected."]
    #[doc = ""]
    #[doc = "  @param[in] jid The joystick whose pointer to set."]
    #[doc = "  @param[in] pointer The new value."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread.  Access is not"]
    #[doc = "  synchronized."]
    #[doc = ""]
    #[doc = "  @sa @ref joystick_userptr"]
    #[doc = "  @sa @ref glfwGetJoystickUserPointer"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetJoystickUserPointer(
        jid: ::std::os::raw::c_int,
        pointer: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Returns the user pointer of the specified joystick."]
    #[doc = ""]
    #[doc = "  This function returns the current value of the user-defined pointer of the"]
    #[doc = "  specified joystick.  The initial value is `NULL`."]
    #[doc = ""]
    #[doc = "  This function may be called from the joystick callback, even for a joystick"]
    #[doc = "  that is being disconnected."]
    #[doc = ""]
    #[doc = "  @param[in] jid The joystick whose pointer to return."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread.  Access is not"]
    #[doc = "  synchronized."]
    #[doc = ""]
    #[doc = "  @sa @ref joystick_userptr"]
    #[doc = "  @sa @ref glfwSetJoystickUserPointer"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetJoystickUserPointer(jid: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Returns whether the specified joystick has a gamepad mapping."]
    #[doc = ""]
    #[doc = "  This function returns whether the specified joystick is both present and has"]
    #[doc = "  a gamepad mapping."]
    #[doc = ""]
    #[doc = "  If the specified joystick is present but does not have a gamepad mapping"]
    #[doc = "  this function will return `GLFW_FALSE` but will not generate an error.  Call"]
    #[doc = "  @ref glfwJoystickPresent to check if a joystick is present regardless of"]
    #[doc = "  whether it has a mapping."]
    #[doc = ""]
    #[doc = "  @param[in] jid The [joystick](@ref joysticks) to query."]
    #[doc = "  @return `GLFW_TRUE` if a joystick is both present and has a gamepad mapping,"]
    #[doc = "  or `GLFW_FALSE` otherwise."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_INVALID_ENUM."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref gamepad"]
    #[doc = "  @sa @ref glfwGetGamepadState"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwJoystickIsGamepad(jid: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Sets the joystick configuration callback."]
    #[doc = ""]
    #[doc = "  This function sets the joystick configuration callback, or removes the"]
    #[doc = "  currently set callback.  This is called when a joystick is connected to or"]
    #[doc = "  disconnected from the system."]
    #[doc = ""]
    #[doc = "  For joystick connection and disconnection events to be delivered on all"]
    #[doc = "  platforms, you need to call one of the [event processing](@ref events)"]
    #[doc = "  functions.  Joystick disconnection may also be detected and the callback"]
    #[doc = "  called by joystick functions.  The function will then return whatever it"]
    #[doc = "  returns if the joystick is not present."]
    #[doc = ""]
    #[doc = "  @param[in] callback The new callback, or `NULL` to remove the currently set"]
    #[doc = "  callback."]
    #[doc = "  @return The previously set callback, or `NULL` if no callback was set or the"]
    #[doc = "  library had not been [initialized](@ref intro_init)."]
    #[doc = ""]
    #[doc = "  @callback_signature"]
    #[doc = "  @code"]
    #[doc = "  void function_name(int jid, int event)"]
    #[doc = "  @endcode"]
    #[doc = "  For more information about the callback parameters, see the"]
    #[doc = "  [function pointer type](@ref GLFWjoystickfun)."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref joystick_event"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetJoystickCallback(callback: GLFWjoystickfun) -> GLFWjoystickfun;
}
extern "C" {
    #[doc = " @brief Adds the specified SDL_GameControllerDB gamepad mappings."]
    #[doc = ""]
    #[doc = "  This function parses the specified ASCII encoded string and updates the"]
    #[doc = "  internal list with any gamepad mappings it finds.  This string may"]
    #[doc = "  contain either a single gamepad mapping or many mappings separated by"]
    #[doc = "  newlines.  The parser supports the full format of the `gamecontrollerdb.txt`"]
    #[doc = "  source file including empty lines and comments."]
    #[doc = ""]
    #[doc = "  See @ref gamepad_mapping for a description of the format."]
    #[doc = ""]
    #[doc = "  If there is already a gamepad mapping for a given GUID in the internal list,"]
    #[doc = "  it will be replaced by the one passed to this function.  If the library is"]
    #[doc = "  terminated and re-initialized the internal list will revert to the built-in"]
    #[doc = "  default."]
    #[doc = ""]
    #[doc = "  @param[in] string The string containing the gamepad mappings."]
    #[doc = "  @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_INVALID_VALUE."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref gamepad"]
    #[doc = "  @sa @ref glfwJoystickIsGamepad"]
    #[doc = "  @sa @ref glfwGetGamepadName"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwUpdateGamepadMappings(
        string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Returns the human-readable gamepad name for the specified joystick."]
    #[doc = ""]
    #[doc = "  This function returns the human-readable name of the gamepad from the"]
    #[doc = "  gamepad mapping assigned to the specified joystick."]
    #[doc = ""]
    #[doc = "  If the specified joystick is not present or does not have a gamepad mapping"]
    #[doc = "  this function will return `NULL` but will not generate an error.  Call"]
    #[doc = "  @ref glfwJoystickPresent to check whether it is present regardless of"]
    #[doc = "  whether it has a mapping."]
    #[doc = ""]
    #[doc = "  @param[in] jid The [joystick](@ref joysticks) to query."]
    #[doc = "  @return The UTF-8 encoded name of the gamepad, or `NULL` if the"]
    #[doc = "  joystick is not present, does not have a mapping or an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned string is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is valid until the specified joystick is"]
    #[doc = "  disconnected, the gamepad mappings are updated or the library is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref gamepad"]
    #[doc = "  @sa @ref glfwJoystickIsGamepad"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetGamepadName(jid: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Retrieves the state of the specified joystick remapped as a gamepad."]
    #[doc = ""]
    #[doc = "  This function retrieves the state of the specified joystick remapped to"]
    #[doc = "  an Xbox-like gamepad."]
    #[doc = ""]
    #[doc = "  If the specified joystick is not present or does not have a gamepad mapping"]
    #[doc = "  this function will return `GLFW_FALSE` but will not generate an error.  Call"]
    #[doc = "  @ref glfwJoystickPresent to check whether it is present regardless of"]
    #[doc = "  whether it has a mapping."]
    #[doc = ""]
    #[doc = "  The Guide button may not be available for input as it is often hooked by the"]
    #[doc = "  system or the Steam client."]
    #[doc = ""]
    #[doc = "  Not all devices have all the buttons or axes provided by @ref"]
    #[doc = "  GLFWgamepadstate.  Unavailable buttons and axes will always report"]
    #[doc = "  `GLFW_RELEASE` and 0.0 respectively."]
    #[doc = ""]
    #[doc = "  @param[in] jid The [joystick](@ref joysticks) to query."]
    #[doc = "  @param[out] state The gamepad input state of the joystick."]
    #[doc = "  @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if no joystick is"]
    #[doc = "  connected, it has no gamepad mapping or an [error](@ref error_handling)"]
    #[doc = "  occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_INVALID_ENUM."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref gamepad"]
    #[doc = "  @sa @ref glfwUpdateGamepadMappings"]
    #[doc = "  @sa @ref glfwJoystickIsGamepad"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.3."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetGamepadState(
        jid: ::std::os::raw::c_int,
        state: *mut GLFWgamepadstate,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Sets the clipboard to the specified string."]
    #[doc = ""]
    #[doc = "  This function sets the system clipboard to the specified, UTF-8 encoded"]
    #[doc = "  string."]
    #[doc = ""]
    #[doc = "  @param[in] window Deprecated.  Any valid window or `NULL`."]
    #[doc = "  @param[in] string A UTF-8 encoded string."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The specified string is copied before this function"]
    #[doc = "  returns."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref clipboard"]
    #[doc = "  @sa @ref glfwGetClipboardString"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetClipboardString(window: *mut GLFWwindow, string: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @brief Returns the contents of the clipboard as a string."]
    #[doc = ""]
    #[doc = "  This function returns the contents of the system clipboard, if it contains"]
    #[doc = "  or is convertible to a UTF-8 encoded string.  If the clipboard is empty or"]
    #[doc = "  if its contents cannot be converted, `NULL` is returned and a @ref"]
    #[doc = "  GLFW_FORMAT_UNAVAILABLE error is generated."]
    #[doc = ""]
    #[doc = "  @param[in] window Deprecated.  Any valid window or `NULL`."]
    #[doc = "  @return The contents of the clipboard as a UTF-8 encoded string, or `NULL`"]
    #[doc = "  if an [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned string is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is valid until the next call to @ref"]
    #[doc = "  glfwGetClipboardString or @ref glfwSetClipboardString, or until the library"]
    #[doc = "  is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function must only be called from the main thread."]
    #[doc = ""]
    #[doc = "  @sa @ref clipboard"]
    #[doc = "  @sa @ref glfwSetClipboardString"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetClipboardString(window: *mut GLFWwindow) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns the GLFW time."]
    #[doc = ""]
    #[doc = "  This function returns the current GLFW time, in seconds.  Unless the time"]
    #[doc = "  has been set using @ref glfwSetTime it measures time elapsed since GLFW was"]
    #[doc = "  initialized."]
    #[doc = ""]
    #[doc = "  This function and @ref glfwSetTime are helper functions on top of @ref"]
    #[doc = "  glfwGetTimerFrequency and @ref glfwGetTimerValue."]
    #[doc = ""]
    #[doc = "  The resolution of the timer is system dependent, but is usually on the order"]
    #[doc = "  of a few micro- or nanoseconds.  It uses the highest-resolution monotonic"]
    #[doc = "  time source on each supported platform."]
    #[doc = ""]
    #[doc = "  @return The current time, in seconds, or zero if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread.  Reading and"]
    #[doc = "  writing of the internal base time is not atomic, so it needs to be"]
    #[doc = "  externally synchronized with calls to @ref glfwSetTime."]
    #[doc = ""]
    #[doc = "  @sa @ref time"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetTime() -> f64;
}
extern "C" {
    #[doc = " @brief Sets the GLFW time."]
    #[doc = ""]
    #[doc = "  This function sets the current GLFW time, in seconds.  The value must be"]
    #[doc = "  a positive finite number less than or equal to 18446744073.0, which is"]
    #[doc = "  approximately 584.5 years."]
    #[doc = ""]
    #[doc = "  This function and @ref glfwGetTime are helper functions on top of @ref"]
    #[doc = "  glfwGetTimerFrequency and @ref glfwGetTimerValue."]
    #[doc = ""]
    #[doc = "  @param[in] time The new value, in seconds."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_INVALID_VALUE."]
    #[doc = ""]
    #[doc = "  @remark The upper limit of GLFW time is calculated as"]
    #[doc = "  floor((2<sup>64</sup> - 1) / 10<sup>9</sup>) and is due to implementations"]
    #[doc = "  storing nanoseconds in 64 bits.  The limit may be increased in the future."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread.  Reading and"]
    #[doc = "  writing of the internal base time is not atomic, so it needs to be"]
    #[doc = "  externally synchronized with calls to @ref glfwGetTime."]
    #[doc = ""]
    #[doc = "  @sa @ref time"]
    #[doc = ""]
    #[doc = "  @since Added in version 2.2."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwSetTime(time: f64);
}
extern "C" {
    #[doc = " @brief Returns the current value of the raw timer."]
    #[doc = ""]
    #[doc = "  This function returns the current value of the raw timer, measured in"]
    #[doc = "  1&nbsp;/&nbsp;frequency seconds.  To get the frequency, call @ref"]
    #[doc = "  glfwGetTimerFrequency."]
    #[doc = ""]
    #[doc = "  @return The value of the timer, or zero if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref time"]
    #[doc = "  @sa @ref glfwGetTimerFrequency"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetTimerValue() -> u64;
}
extern "C" {
    #[doc = " @brief Returns the frequency, in Hz, of the raw timer."]
    #[doc = ""]
    #[doc = "  This function returns the frequency, in Hz, of the raw timer."]
    #[doc = ""]
    #[doc = "  @return The frequency of the timer, in Hz, or zero if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref time"]
    #[doc = "  @sa @ref glfwGetTimerValue"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup input"]
    pub fn glfwGetTimerFrequency() -> u64;
}
extern "C" {
    #[doc = " @brief Makes the context of the specified window current for the calling"]
    #[doc = "  thread."]
    #[doc = ""]
    #[doc = "  This function makes the OpenGL or OpenGL ES context of the specified window"]
    #[doc = "  current on the calling thread.  A context must only be made current on"]
    #[doc = "  a single thread at a time and each thread can have only a single current"]
    #[doc = "  context at a time."]
    #[doc = ""]
    #[doc = "  When moving a context between threads, you must make it non-current on the"]
    #[doc = "  old thread before making it current on the new one."]
    #[doc = ""]
    #[doc = "  By default, making a context non-current implicitly forces a pipeline flush."]
    #[doc = "  On machines that support `GL_KHR_context_flush_control`, you can control"]
    #[doc = "  whether a context performs this flush by setting the"]
    #[doc = "  [GLFW_CONTEXT_RELEASE_BEHAVIOR](@ref GLFW_CONTEXT_RELEASE_BEHAVIOR_hint)"]
    #[doc = "  hint."]
    #[doc = ""]
    #[doc = "  The specified window must have an OpenGL or OpenGL ES context.  Specifying"]
    #[doc = "  a window without a context will generate a @ref GLFW_NO_WINDOW_CONTEXT"]
    #[doc = "  error."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose context to make current, or `NULL` to"]
    #[doc = "  detach the current context."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_NO_WINDOW_CONTEXT and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref context_current"]
    #[doc = "  @sa @ref glfwGetCurrentContext"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup context"]
    pub fn glfwMakeContextCurrent(window: *mut GLFWwindow);
}
extern "C" {
    #[doc = " @brief Returns the window whose context is current on the calling thread."]
    #[doc = ""]
    #[doc = "  This function returns the window whose OpenGL or OpenGL ES context is"]
    #[doc = "  current on the calling thread."]
    #[doc = ""]
    #[doc = "  @return The window whose context is current, or `NULL` if no window's"]
    #[doc = "  context is current."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref context_current"]
    #[doc = "  @sa @ref glfwMakeContextCurrent"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.0."]
    #[doc = ""]
    #[doc = "  @ingroup context"]
    pub fn glfwGetCurrentContext() -> *mut GLFWwindow;
}
extern "C" {
    #[doc = " @brief Swaps the front and back buffers of the specified window."]
    #[doc = ""]
    #[doc = "  This function swaps the front and back buffers of the specified window when"]
    #[doc = "  rendering with OpenGL or OpenGL ES.  If the swap interval is greater than"]
    #[doc = "  zero, the GPU driver waits the specified number of screen updates before"]
    #[doc = "  swapping the buffers."]
    #[doc = ""]
    #[doc = "  The specified window must have an OpenGL or OpenGL ES context.  Specifying"]
    #[doc = "  a window without a context will generate a @ref GLFW_NO_WINDOW_CONTEXT"]
    #[doc = "  error."]
    #[doc = ""]
    #[doc = "  This function does not apply to Vulkan.  If you are rendering with Vulkan,"]
    #[doc = "  see `vkQueuePresentKHR` instead."]
    #[doc = ""]
    #[doc = "  @param[in] window The window whose buffers to swap."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_NO_WINDOW_CONTEXT and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark __EGL:__ The context of the specified window must be current on the"]
    #[doc = "  calling thread."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref buffer_swap"]
    #[doc = "  @sa @ref glfwSwapInterval"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = "  @glfw3 Added window handle parameter."]
    #[doc = ""]
    #[doc = "  @ingroup window"]
    pub fn glfwSwapBuffers(window: *mut GLFWwindow);
}
extern "C" {
    #[doc = " @brief Sets the swap interval for the current context."]
    #[doc = ""]
    #[doc = "  This function sets the swap interval for the current OpenGL or OpenGL ES"]
    #[doc = "  context, i.e. the number of screen updates to wait from the time @ref"]
    #[doc = "  glfwSwapBuffers was called before swapping the buffers and returning.  This"]
    #[doc = "  is sometimes called _vertical synchronization_, _vertical retrace"]
    #[doc = "  synchronization_ or just _vsync_."]
    #[doc = ""]
    #[doc = "  A context that supports either of the `WGL_EXT_swap_control_tear` and"]
    #[doc = "  `GLX_EXT_swap_control_tear` extensions also accepts _negative_ swap"]
    #[doc = "  intervals, which allows the driver to swap immediately even if a frame"]
    #[doc = "  arrives a little bit late.  You can check for these extensions with @ref"]
    #[doc = "  glfwExtensionSupported."]
    #[doc = ""]
    #[doc = "  A context must be current on the calling thread.  Calling this function"]
    #[doc = "  without a current context will cause a @ref GLFW_NO_CURRENT_CONTEXT error."]
    #[doc = ""]
    #[doc = "  This function does not apply to Vulkan.  If you are rendering with Vulkan,"]
    #[doc = "  see the present mode of your swapchain instead."]
    #[doc = ""]
    #[doc = "  @param[in] interval The minimum number of screen updates to wait for"]
    #[doc = "  until the buffers are swapped by @ref glfwSwapBuffers."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_NO_CURRENT_CONTEXT and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark This function is not called during context creation, leaving the"]
    #[doc = "  swap interval set to whatever is the default on that platform.  This is done"]
    #[doc = "  because some swap interval extensions used by GLFW do not allow the swap"]
    #[doc = "  interval to be reset to zero once it has been set to a non-zero value."]
    #[doc = ""]
    #[doc = "  @remark Some GPU drivers do not honor the requested swap interval, either"]
    #[doc = "  because of a user setting that overrides the application's request or due to"]
    #[doc = "  bugs in the driver."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref buffer_swap"]
    #[doc = "  @sa @ref glfwSwapBuffers"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = ""]
    #[doc = "  @ingroup context"]
    pub fn glfwSwapInterval(interval: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Returns whether the specified extension is available."]
    #[doc = ""]
    #[doc = "  This function returns whether the specified"]
    #[doc = "  [API extension](@ref context_glext) is supported by the current OpenGL or"]
    #[doc = "  OpenGL ES context.  It searches both for client API extension and context"]
    #[doc = "  creation API extensions."]
    #[doc = ""]
    #[doc = "  A context must be current on the calling thread.  Calling this function"]
    #[doc = "  without a current context will cause a @ref GLFW_NO_CURRENT_CONTEXT error."]
    #[doc = ""]
    #[doc = "  As this functions retrieves and searches one or more extension strings each"]
    #[doc = "  call, it is recommended that you cache its results if it is going to be used"]
    #[doc = "  frequently.  The extension strings will not change during the lifetime of"]
    #[doc = "  a context, so there is no danger in doing this."]
    #[doc = ""]
    #[doc = "  This function does not apply to Vulkan.  If you are using Vulkan, see @ref"]
    #[doc = "  glfwGetRequiredInstanceExtensions, `vkEnumerateInstanceExtensionProperties`"]
    #[doc = "  and `vkEnumerateDeviceExtensionProperties` instead."]
    #[doc = ""]
    #[doc = "  @param[in] extension The ASCII encoded name of the extension."]
    #[doc = "  @return `GLFW_TRUE` if the extension is available, or `GLFW_FALSE`"]
    #[doc = "  otherwise."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_NO_CURRENT_CONTEXT, @ref GLFW_INVALID_VALUE and @ref"]
    #[doc = "  GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref context_glext"]
    #[doc = "  @sa @ref glfwGetProcAddress"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = ""]
    #[doc = "  @ingroup context"]
    pub fn glfwExtensionSupported(
        extension: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Returns the address of the specified function for the current"]
    #[doc = "  context."]
    #[doc = ""]
    #[doc = "  This function returns the address of the specified OpenGL or OpenGL ES"]
    #[doc = "  [core or extension function](@ref context_glext), if it is supported"]
    #[doc = "  by the current context."]
    #[doc = ""]
    #[doc = "  A context must be current on the calling thread.  Calling this function"]
    #[doc = "  without a current context will cause a @ref GLFW_NO_CURRENT_CONTEXT error."]
    #[doc = ""]
    #[doc = "  This function does not apply to Vulkan.  If you are rendering with Vulkan,"]
    #[doc = "  see @ref glfwGetInstanceProcAddress, `vkGetInstanceProcAddr` and"]
    #[doc = "  `vkGetDeviceProcAddr` instead."]
    #[doc = ""]
    #[doc = "  @param[in] procname The ASCII encoded name of the function."]
    #[doc = "  @return The address of the function, or `NULL` if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED, @ref"]
    #[doc = "  GLFW_NO_CURRENT_CONTEXT and @ref GLFW_PLATFORM_ERROR."]
    #[doc = ""]
    #[doc = "  @remark The address of a given function is not guaranteed to be the same"]
    #[doc = "  between contexts."]
    #[doc = ""]
    #[doc = "  @remark This function may return a non-`NULL` address despite the"]
    #[doc = "  associated version or extension not being available.  Always check the"]
    #[doc = "  context version or extension string first."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned function pointer is valid until the context"]
    #[doc = "  is destroyed or the library is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref context_glext"]
    #[doc = "  @sa @ref glfwExtensionSupported"]
    #[doc = ""]
    #[doc = "  @since Added in version 1.0."]
    #[doc = ""]
    #[doc = "  @ingroup context"]
    pub fn glfwGetProcAddress(procname: *const ::std::os::raw::c_char) -> GLFWglproc;
}
extern "C" {
    #[doc = " @brief Returns whether the Vulkan loader and an ICD have been found."]
    #[doc = ""]
    #[doc = "  This function returns whether the Vulkan loader and any minimally functional"]
    #[doc = "  ICD have been found."]
    #[doc = ""]
    #[doc = "  The availability of a Vulkan loader and even an ICD does not by itself"]
    #[doc = "  guarantee that surface creation or even instance creation is possible."]
    #[doc = "  For example, on Fermi systems Nvidia will install an ICD that provides no"]
    #[doc = "  actual Vulkan support.  Call @ref glfwGetRequiredInstanceExtensions to check"]
    #[doc = "  whether the extensions necessary for Vulkan surface creation are available"]
    #[doc = "  and @ref glfwGetPhysicalDevicePresentationSupport to check whether a queue"]
    #[doc = "  family of a physical device supports image presentation."]
    #[doc = ""]
    #[doc = "  @return `GLFW_TRUE` if Vulkan is minimally available, or `GLFW_FALSE`"]
    #[doc = "  otherwise."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref vulkan_support"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup vulkan"]
    pub fn glfwVulkanSupported() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Returns the Vulkan instance extensions required by GLFW."]
    #[doc = ""]
    #[doc = "  This function returns an array of names of Vulkan instance extensions required"]
    #[doc = "  by GLFW for creating Vulkan surfaces for GLFW windows.  If successful, the"]
    #[doc = "  list will always contain `VK_KHR_surface`, so if you don't require any"]
    #[doc = "  additional extensions you can pass this list directly to the"]
    #[doc = "  `VkInstanceCreateInfo` struct."]
    #[doc = ""]
    #[doc = "  If Vulkan is not available on the machine, this function returns `NULL` and"]
    #[doc = "  generates a @ref GLFW_API_UNAVAILABLE error.  Call @ref glfwVulkanSupported"]
    #[doc = "  to check whether Vulkan is at least minimally available."]
    #[doc = ""]
    #[doc = "  If Vulkan is available but no set of extensions allowing window surface"]
    #[doc = "  creation was found, this function returns `NULL`.  You may still use Vulkan"]
    #[doc = "  for off-screen rendering and compute work."]
    #[doc = ""]
    #[doc = "  @param[out] count Where to store the number of extensions in the returned"]
    #[doc = "  array.  This is set to zero if an error occurred."]
    #[doc = "  @return An array of ASCII encoded extension names, or `NULL` if an"]
    #[doc = "  [error](@ref error_handling) occurred."]
    #[doc = ""]
    #[doc = "  @errors Possible errors include @ref GLFW_NOT_INITIALIZED and @ref"]
    #[doc = "  GLFW_API_UNAVAILABLE."]
    #[doc = ""]
    #[doc = "  @remark Additional extensions may be required by future versions of GLFW."]
    #[doc = "  You should check if any extensions you wish to enable are already in the"]
    #[doc = "  returned array, as it is an error to specify an extension more than once in"]
    #[doc = "  the `VkInstanceCreateInfo` struct."]
    #[doc = ""]
    #[doc = "  @remark @macos This function currently supports either the"]
    #[doc = "  `VK_MVK_macos_surface` extension from MoltenVK or `VK_EXT_metal_surface`"]
    #[doc = "  extension."]
    #[doc = ""]
    #[doc = "  @pointer_lifetime The returned array is allocated and freed by GLFW.  You"]
    #[doc = "  should not free it yourself.  It is guaranteed to be valid only until the"]
    #[doc = "  library is terminated."]
    #[doc = ""]
    #[doc = "  @thread_safety This function may be called from any thread."]
    #[doc = ""]
    #[doc = "  @sa @ref vulkan_ext"]
    #[doc = "  @sa @ref glfwCreateWindowSurface"]
    #[doc = ""]
    #[doc = "  @since Added in version 3.2."]
    #[doc = ""]
    #[doc = "  @ingroup vulkan"]
    pub fn glfwGetRequiredInstanceExtensions(count: *mut u32)
        -> *mut *const ::std::os::raw::c_char;
}
